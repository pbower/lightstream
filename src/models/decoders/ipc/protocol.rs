//! Arrow IPC Frame Decoder
//!
//! Decodes Arrow IPC (Inter-Process Communication) frames for both *file* and *stream* protocols,
//! as defined by the official [Apache Arrow Columnar IPC specification](https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format).
//!
//! # Overview
//!
//! - **File protocol**: bounded, random-access, with header magic, aligned frames, and trailing magic/footer.
//! - **Stream protocol**: unbounded, always emits 8-byte continuation markers before each message frame (for chunking/streaming).
//! - Handles frame parsing, alignment, footer recognition, and correct protocol-specific state transitions.
//!
//! The decoder works as a state machine, consuming input buffers and producing `ArrowIPCMessage` instances as complete frames are detected.
//!
//! # Usage
//!
//! Instantiate via [`ArrowIPCFrameDecoder::new(protocol)`] for the desired protocol.
//! Feed it with input buffers (possibly incomplete), and it will return either:
//! - [`DecodeResult::NeedMore`] if more input is required for a full frame.
//! - [`DecodeResult::Frame { frame, consumed }`] when a full message+body has been parsed.
//!
//! Supports incremental decoding and protocol autodetection where permitted by the Arrow spec.

use std::io;
use std::marker::PhantomData;

use crate::constants::{
    ARROW_MAGIC_NUMBER, ARROW_MAGIC_NUMBER_PADDED, CONTINUATION_MARKER_LEN, CONTINUATION_SENTINEL, FILE_CLOSING_MAGIC_LEN, FILE_OPENING_MAGIC_LEN, METADATA_SIZE_PREFIX
};
use crate::enums::{DecodeResult, DecodeState, IPCMessageProtocol};
use crate::models::frames::ipc_message::ArrowIPCMessage;
use crate::traits::frame_decoder::FrameDecoder;
use crate::traits::stream_buffer::StreamBuffer;
use crate::utils::align_8;


/// Decoder for Arrow IPC (file/stream) format state machine.
//
/// See [Arrow IPC Streaming Format](https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format)
/// and [Arrow File Format](https://arrow.apache.org/docs/format/Columnar.html#ipc-file-format)
pub struct ArrowIPCFrameDecoder<B: StreamBuffer> {
    format: IPCMessageProtocol,
    state: DecodeState<B>,
    _phantom: PhantomData<B>
}

impl<B: StreamBuffer> FrameDecoder for ArrowIPCFrameDecoder<B> {
    type Frame = ArrowIPCMessage<B>;

    /// Main decode entry point.
    ///
    /// - Accepts any size buffer (may be partial).
    /// - Returns `DecodeResult::NeedMore` if not enough data for a full frame.
    /// - Returns `DecodeResult::Frame` with message and body if a full frame is available.
    /// - Consumes the minimum required bytes per frame.
    fn decode(&mut self, buf: &[u8]) -> io::Result<DecodeResult<Self::Frame>> {
        loop {
            // Protocol auto-detect for Stream-with-File-magic: switch to File mode if magic is detected at head
            if matches!(self.state, DecodeState::Initial)
                && matches!(self.format, IPCMessageProtocol::Stream)
                && Self::has_opening_file_magic(buf)
            {
                self.format = IPCMessageProtocol::File;
                self.state = DecodeState::ReadingMessageLength;
                continue;
            }

            let state = std::mem::replace(&mut self.state, DecodeState::Initial);
            let result = match state {
                DecodeState::Initial => self.decode_initial(buf)?,
                DecodeState::ReadingContinuationSize { .. } => self.decode_continuation_size(buf)?,
                DecodeState::ReadingMessageLength => self.decode_message_length(buf)?,
                DecodeState::ReadingMessage { msg_len } => self.decode_message(buf, msg_len)?,
                DecodeState::ReadingBody { body_len, message } => {
                                            self.decode_body(buf, body_len, message)?
                                        }
                DecodeState::ReadingFooter { footer_len, footer_offset } => {
                                            self.decode_footer(buf, footer_len, footer_offset)?
                                        }
                DecodeState::Done => return Ok(DecodeResult::NeedMore),
                DecodeState::AfterMagic => {
                    // After file magic, immediately proceed to reading message length at offset 8
                    self.state = DecodeState::ReadingMessageLength;
                    continue;
                }
                DecodeState::AfterContMarker => {
                    // After continuation marker, proceed to reading message length at offset 4
                    self.state = DecodeState::ReadingMessageLength;
                    continue;
                }
            };

            if let Some(val) = result {
                return Ok(val);
            }
        }
    }
}

impl<B: StreamBuffer> ArrowIPCFrameDecoder<B> {
    /// Construct a new decoder for the given Arrow IPC protocol.
    ///
    /// - `IPCMessageProtocol::Stream`: expects stream continuation markers before each message.
    /// - `IPCMessageProtocol::File`: expects file magic, trailing magic/footer, and aligned frames.
    pub fn new(format: IPCMessageProtocol) -> Self {
        Self {
            format,
            state: DecodeState::Initial,
            _phantom: PhantomData
        }
    }

    /// Construct a decoder that skips file magic validation (for some advanced usages).
    /// Only for scenarios where the header is known valid or has already been checked.
    pub fn new_without_header_check(format: IPCMessageProtocol) -> Self {
        // Only for File: skip the header, start directly at message length
        Self {
            format,
            state: if format == IPCMessageProtocol::File {
                DecodeState::ReadingMessageLength
            } else {
                DecodeState::Initial
            },
            _phantom: PhantomData
        }
    }

    /// Reads a little-endian u32 from the provided slice (at start of slice).
    #[inline]
    fn read_u32_le(buf: &[u8]) -> u32 {
        u32::from_le_bytes(buf[..4].try_into().unwrap())
    }

    /// Returns true if the buffer starts with valid Arrow file magic.
    /// (`b"ARROW1\0\0"`)
    #[inline]
    fn has_opening_file_magic(buf: &[u8]) -> bool {
        buf.len() >= FILE_OPENING_MAGIC_LEN && &buf[..8] == ARROW_MAGIC_NUMBER_PADDED
    }

    /// Returns true if the buffer starts with a valid Arrow stream continuation marker.
    /// (`0xFFFF_FFFF`)
    #[inline]
    fn has_continuation_sentinel(buf: &[u8]) -> bool {
        buf.len() >= METADATA_SIZE_PREFIX && Self::read_u32_le(buf) == CONTINUATION_SENTINEL
    }

    #[inline]
    fn has_file_footer_markers(buf: &[u8], offset: usize, msg_len: usize) -> bool {
        msg_len > 0
            && offset + METADATA_SIZE_PREFIX + msg_len + FILE_OPENING_MAGIC_LEN <= buf.len()
    }

    #[inline]
    fn has_eos_marker(buf: &[u8]) -> bool {
        buf.len() >= 8
                    && Self::read_u32_le(&buf[0..4]) == 0xFFFF_FFFF
                    && Self::read_u32_le(&buf[4..8]) == 0x0000_0000
    }

    /// Returns current message offset for the *start* of message metadata,
    /// based on protocol and state.
    #[inline]
    fn get_message_offset(&self) -> usize {
        match self.state {
            DecodeState::AfterMagic => FILE_OPENING_MAGIC_LEN,
            DecodeState::AfterContMarker => CONTINUATION_MARKER_LEN,
            _ => 0,
        }
    }

    /// Handles initial protocol-specific header detection (magic or marker).
    #[inline]
    fn decode_initial(&mut self, buf: &[u8]) -> io::Result<Option<DecodeResult<ArrowIPCMessage<B>>>> {
        match self.format {
            IPCMessageProtocol::File => {
                if buf.len() < FILE_OPENING_MAGIC_LEN {
                    return Ok(Some(DecodeResult::NeedMore));
                }
                if !Self::has_opening_file_magic(buf) {
                    return Err(io::Error::new(
                        io::ErrorKind::InvalidData,
                        "Invalid Arrow file magic header"
                    ));
                }
                self.state = DecodeState::AfterMagic;
            }
            IPCMessageProtocol::Stream => {
                // Check for EOS: 0xFFFF_FFFF + 0x00000000 (8 bytes)
                if Self::has_eos_marker(buf) {
                    return Ok(Some(DecodeResult::Frame {
                        frame: ArrowIPCMessage {
                            message: B::default(),
                            body: B::default(),
                        },
                        consumed: 8,
                    }));
                }
                if Self::has_continuation_sentinel(buf) {
                    if buf.len() < CONTINUATION_MARKER_LEN {
                        return Ok(Some(DecodeResult::NeedMore));
                    }
                    self.state = DecodeState::AfterContMarker;
                } else {
                    // (per spec, this can be legal if writer skips marker on very first frame)
                    self.state = DecodeState::ReadingMessageLength;
                }
            }
        }
        Ok(None)
    }

    /// Handles parsing the length prefix for the next Arrow IPC message.
    #[inline]
    fn decode_message_length(
        &mut self,
        buf: &[u8]
    ) -> io::Result<Option<DecodeResult<ArrowIPCMessage<B>>>> {
        let offset = self.get_message_offset();

        // Stream EOS detection: 0xFFFF_FFFF + 0x00000000
        if self.format == IPCMessageProtocol::Stream && Self::has_eos_marker(buf) {
            return Ok(Some(DecodeResult::Frame {
                frame: ArrowIPCMessage {
                    message: B::default(),
                    body: B::default(),
                },
                consumed: offset + 8,
            }));
        }

        if buf.len() < offset + METADATA_SIZE_PREFIX {
            return Ok(Some(DecodeResult::NeedMore));
        }
        let msg_len = Self::read_u32_le(&buf[offset..offset + METADATA_SIZE_PREFIX]) as usize;

        if self.format == IPCMessageProtocol::File
            && Self::has_file_footer_markers(buf, offset, msg_len)
        {
            let possible_footer_magic = &buf[offset + METADATA_SIZE_PREFIX + msg_len
                ..offset + METADATA_SIZE_PREFIX + msg_len + FILE_OPENING_MAGIC_LEN];
            if possible_footer_magic == ARROW_MAGIC_NUMBER {
                self.state = DecodeState::ReadingFooter {
                    footer_len: msg_len,
                    footer_offset: offset + METADATA_SIZE_PREFIX
                };
                return Ok(None);
            }
        }

        if msg_len == 0 {
            return Err(io::Error::new(io::ErrorKind::InvalidData, "Zero-length message"));
        }
        self.state = DecodeState::ReadingMessage { msg_len };
        Ok(None)
    }

    /// Ensures correct calculation of metadata and body alignment per Arrow IPC specification.
    /// Handles decoding the Arrow FlatBuffers message, and sets up body parsing if required.
    #[inline]
    fn decode_message(
        &mut self,
        buf: &[u8],
        msg_len: usize
    ) -> io::Result<Option<DecodeResult<ArrowIPCMessage<B>>>> {
        let offset = self.get_message_offset();

        let meta_start = offset + METADATA_SIZE_PREFIX;
        let meta_end = meta_start + msg_len;
        if buf.len() < meta_end {
            return Ok(Some(DecodeResult::NeedMore));
        }

        let metadata = &buf[meta_start..meta_end];
        let message = B::from_slice(metadata);

        use flatbuffers::root;
        use crate::AFMessage;
        let root = root::<AFMessage>(&message.as_ref()).map_err(|e| {
            io::Error::new(io::ErrorKind::InvalidData, format!("Failed to parse message: {e}"))
        })?;
        let body_len = root.bodyLength() as usize;

        if body_len > 0 {
            let body_start = meta_end;
            let body_end = body_start + body_len;
            if buf.len() < body_end {
                self.state = DecodeState::ReadingBody {
                    body_len,
                    message: message,
                };
                return Ok(Some(DecodeResult::NeedMore));
            }
            let body = B::from_slice(&buf[body_start..body_end]);
            let frame = ArrowIPCMessage::<B> { message, body };
            self.state = DecodeState::ReadingMessageLength;
            let consumed = (meta_start - offset) + msg_len + body_len;
            return Ok(Some(DecodeResult::Frame { frame, consumed }));
        } else {
            let consumed = offset + METADATA_SIZE_PREFIX + msg_len;
            let frame = ArrowIPCMessage { message, body: B::default() };
            self.state = DecodeState::ReadingMessageLength;
            return Ok(Some(DecodeResult::Frame { frame, consumed }));
        }
    }
    
    #[inline]
    fn decode_continuation_size(
        &mut self,
        buf: &[u8]
    ) -> io::Result<Option<DecodeResult<ArrowIPCMessage<B>>>> {
        // Must have at least 8 bytes: 4 for marker, 4 for metadata size
        if buf.len() < 8 {
            return Ok(Some(DecodeResult::NeedMore));
        }
        // Validate marker is correct (0xFFFF_FFFF)
        let marker = Self::read_u32_le(&buf[0..4]);
        if marker != 0xFFFF_FFFF {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!("Invalid Arrow stream continuation marker: expected 0xFFFF_FFFF, found 0x{:08X}", marker),
            ));
        }
        // Read metadata size (little-endian u32 at offset 4)
        let meta_size = Self::read_u32_le(&buf[4..8]) as usize;
    
        // If this is a stream EOS marker (meta_size == 0), treat as EOS elsewhere (decode_message_length or decode_initial)
        if meta_size == 0 {
            // The decode_message_length/initial logic will consume EOS, not here.
            self.state = DecodeState::ReadingMessageLength;
            return Ok(None);
        }
    
        // After marker+length, parse the message of advertised length
        self.state = DecodeState::ReadingMessage { msg_len: meta_size };
        Ok(None)
    }
    
    /// Handles extracting the Arrow body payload from the input buffer.
    #[inline]
    fn decode_body(
        &mut self,
        buf: &[u8],
        body_len: usize,
        message: B
    ) -> io::Result<Option<DecodeResult<ArrowIPCMessage<B>>>> {
        let offset = self.get_message_offset();
        let meta_pad = align_8(message.len());
        let meta_tot = match self.format {
            IPCMessageProtocol::Stream => {
                // STREAM: metadata follows marker, no extra size prefix
                message.len() + meta_pad
            }
            IPCMessageProtocol::File => {
                // FILE: 4-byte metadata size prefix before metadata
                METADATA_SIZE_PREFIX + message.len() + meta_pad
            }
        };
        let needed = offset + meta_tot + body_len;
        if buf.len() < needed {
            return Ok(Some(DecodeResult::NeedMore));
        }
        let bstart = offset + meta_tot;
        let bend = bstart + body_len;
        let body = B::from_slice(&buf[bstart..bend]);
        let frame = ArrowIPCMessage::<B> { message, body };
        self.state = DecodeState::ReadingMessageLength;
        Ok(Some(DecodeResult::Frame { frame, consumed: needed }))
    }
    
    /// Handles decoding of file footer and trailing magic in Arrow File protocol.
    /// Validates the footer size and Arrow magic, errors if footer is malformed or truncated.
    #[inline]
    fn decode_footer(
        &mut self,
        buf: &[u8],
        footer_len: usize,
        footer_offset: usize
    ) -> io::Result<Option<DecodeResult<ArrowIPCMessage<B>>>> {
        // Wait for at least enough for the footer data
        if buf.len() < footer_offset + footer_len {
            return Ok(Some(DecodeResult::NeedMore));
        }
        // Wait for enough for footer size (u32 LE) and trailing magic (6 or 8 bytes)
        if buf.len() < footer_offset + footer_len + 4 + FILE_CLOSING_MAGIC_LEN {
            return Ok(Some(DecodeResult::NeedMore));
        }
        let size_offset = footer_offset + footer_len;
        let footer_size =
            u32::from_le_bytes(buf[size_offset..size_offset + 4].try_into().unwrap()) as usize;
        if footer_size != footer_len {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!(
                    "Arrow file footer size mismatch: expected {footer_len}, found {footer_size}"
                )
            ));
        }
        let magic = &buf[size_offset + 4..size_offset + 4 + FILE_CLOSING_MAGIC_LEN];
        if magic != ARROW_MAGIC_NUMBER {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "Invalid Arrow file trailing magic",
            ));
        }
        // No more frames to follow: mark as Done
        self.state = DecodeState::Done;
        Ok(None)
    }

}

impl<B: StreamBuffer> Default for ArrowIPCFrameDecoder<B> {
    /// Returns a decoder in stream protocol mode
    fn default() -> Self {
        ArrowIPCFrameDecoder::new(IPCMessageProtocol::Stream)
    }
}

// #[cfg(test)]
// mod tests {
//     use flatbuffers::FlatBufferBuilder;

//     use super::*;
//     use crate::arrow::message::org::apache::arrow::flatbuf as fb;
//     use crate::enums::IPCMessageProtocol;
//     use crate::models::encoders::ipc_encoder::ArrowIPCEncoder;

//     // Simple case
//     //
//     // ```python
//     // import pyarrow as pa
//     // import pyarrow.ipc
//     //
//     // # Define a sample Arrow schema and record batch
//     // schema = pa.schema([
//     //     ('a', pa.int32()),
//     //     ('b', pa.string())
//     // ])
//     //
//     // batch = pa.record_batch([
//     //     pa.array([1, 2, 3, 4], type=pa.int32()),
//     //     pa.array(['foo', 'bar', 'baz', 'qux'], type=pa.string())
//     // ], schema=schema)
//     //
//     // # Write stream format (.arrows)
//     // with open("arrow_reference_stream.arrows", "wb") as f:
//     //     with pa.ipc.new_stream(f, schema) as writer:
//     //         writer.write_batch(batch)
//     //
//     // # Write file format (.arrow)
//     // with open("arrow_reference_file.arrow", "wb") as f:
//     //     with pa.ipc.new_file(f, schema) as writer:
//     //         writer.write_batch(batch)
//     //
//     // # For embedding as Rust const bytes, you can do:
//     // with open("arrow_reference_stream.arrows", "rb") as f:
//     //     stream_bytes = f.read()
//     // print("STREAM FORMAT (for Rust):\nconst ARROW_REFERENCE_STREAM: &[u8] = &[\n    {} \n];"
//     //     .format(', '.join(f'0x{b:02x}' for b in stream_bytes)))
//     //
//     // with open("arrow_reference_file.arrow", "rb") as f:
//     //     file_bytes = f.read()
//     // print("FILE FORMAT (for Rust):\nconst ARROW_REFERENCE_FILE: &[u8] = &[\n    {} \n];"
//     //     .format(', '.join(f'0x{b:02x}' for b in file_bytes)))
//     //```

//     const ARROW_REFERENCE_STREAM_BASIC: &[u8] = &[
//         0xff, 0xff, 0xff, 0xff, 0xa8, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
//         0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08,
//         0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
//         0x04, 0x00, 0x00, 0x00, 0xd8, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x05, 0x10, 0x00, 0x00,
//         0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
//         0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10,
//         0x00, 0x14, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00,
//         0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00,
//         0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x61, 0x00,
//         0x00, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
//         0xc8, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x16,
//         0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x03,
//         0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00,
//         0x6c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00,
//         0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
//         0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x62, 0x61, 0x7a, 0x71, 0x75,
//         0x78, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
//     ];

//     const ARROW_REFERENCE_FILE_BASIC: &[u8] = &[
//         0x41, 0x52, 0x52, 0x4f, 0x57, 0x31, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xa8, 0x00, 0x00,
//         0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00,
//         0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x08,
//         0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
//         0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xd8, 0xff, 0xff,
//         0xff, 0x00, 0x00, 0x01, 0x05, 0x10, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00, 0x08, 0x00, 0x06, 0x00,
//         0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x02, 0x10, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x08,
//         0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x16, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00,
//         0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0x38,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00,
//         0x04, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
//         0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
//         0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
//         0x09, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f,
//         0x62, 0x61, 0x72, 0x62, 0x61, 0x7a, 0x71, 0x75, 0x78, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
//         0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x14, 0x00, 0x06,
//         0x00, 0x08, 0x00, 0x0c, 0x00, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
//         0x38, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
//         0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00,
//         0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
//         0x00, 0xd8, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x05, 0x10, 0x00, 0x00, 0x00, 0x18, 0x00,
//         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62,
//         0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00,
//         0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x04, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x08,
//         0x00, 0x0c, 0x00, 0x08, 0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x20, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x41, 0x52, 0x52, 0x4f, 0x57, 0x31
//     ];

//     #[test]
//     fn test_decode_basic_stream_from_reference_arrow() {
//         let reference_stream_bytes: &[u8] = ARROW_REFERENCE_STREAM_BASIC;
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::Stream);
//         let mut offset = 0;
//         let mut num_frames = 0;
//         while offset < reference_stream_bytes.len() {
//             match decoder.decode(&reference_stream_bytes[offset..]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => {
//                     assert!(frame.message.len() > 0);
//                     offset += consumed;
//                     num_frames += 1;
//                 }
//                 DecodeResult::NeedMore => break
//             }
//         }
//         assert!(num_frames >= 2);
//     }

//     #[test]
//     fn test_decode_basic_file_from_reference_arrow() {
//         let reference_file_bytes: &[u8] = ARROW_REFERENCE_FILE_BASIC;
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::File);
//         let mut offset = 0;
//         let mut num_frames = 0;
//         while offset < reference_file_bytes.len() {
//             println!("{:?}", decoder.decode(&reference_file_bytes[offset..]).unwrap());
//             match decoder.decode(&reference_file_bytes[offset..]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => {
//                     assert!(frame.message.len() > 0);
//                     offset += consumed;
//                     num_frames += 1;
//                 }
//                 DecodeResult::NeedMore => break
//             }
//         }
//         println!("{}", num_frames);
//         assert!(num_frames >= 2);
//     }

//     //  Complex case:
//     // ```python
//     //    import pyarrow as pa
//     //    import pyarrow.ipc
//     //    import numpy as np
//     //    import datetime
//     //
//     //    # All arrays length 7
//     //    int64_data   = [10000000000, -10000000000, 123456789012, -1, 0, 888, -888]
//     //    float32_data = [3.14, np.nan, -2.71, 0.0, 42.0, -999.25, 1.25]
//     //    float64_data = [1e100, -1e-100, 0.0, 2.0, -3.333, 1.5, 7.77]
//     //    bool_data    = [True, False, True, False, True, True, False]
//     //    labels       = pa.array(['alpha', 'beta', 'alpha', 'gamma', 'beta', 'gamma', 'delta'])
//     //    dict_type    = pa.dictionary(pa.int32(), pa.string())
//     //    dict_array   = labels.cast(dict_type)
//     //
//     //    schema = pa.schema([
//     //        ('int64_col', pa.int64()),
//     //        ('float32_col', pa.float32()),
//     //        ('float64_col', pa.float64()),
//     //        ('bool_col', pa.bool_()),
//     //        ('dict_col', dict_type),
//     //    ])
//     //
//     //    batch = pa.record_batch([
//     //        pa.array(int64_data, type=pa.int64()),
//     //        pa.array(float32_data, type=pa.float32()),
//     //        pa.array(float64_data, type=pa.float64()),
//     //        pa.array(bool_data, type=pa.bool_()),
//     //        dict_array,
//     //    ], schema=schema)
//     //
//     //    # Write stream format (.arrows)
//     //    with open("arrow_complex_stream.arrows", "wb") as f:
//     //        with pa.ipc.new_stream(f, schema) as writer:
//     //            writer.write_batch(batch)
//     //
//     //    # Write file format (.arrow)
//     //    with open("arrow_complex_file.arrow", "wb") as f:
//     //        with pa.ipc.new_file(f, schema) as writer:
//     //            writer.write_batch(batch)
//     //
//     //    # Print Rust consts for embedding
//     //    with open("arrow_complex_stream.arrows", "rb") as f:
//     //        stream_bytes = f.read()
//     //    print("COMPLEX STREAM FORMAT (for Rust):\nconst ARROW_COMPLEX_STREAM: &[u8] = &[\n    {} \n];"
//     //        .format(', '.join(f'0x{b:02x}' for b in stream_bytes)))
//     //
//     //    with open("arrow_complex_file.arrow", "rb") as f:
//     //        file_bytes = f.read()
//     //    print("COMPLEX FILE FORMAT (for Rust):\nconst ARROW_COMPLEX_FILE: &[u8] = &[\n    {} \n];"
//     //        .format(', '.join(f'0x{b:02x}' for b in file_bytes)))
//     // ```

//     const ARROW_COMPLEX_STREAM: &[u8] = &[
//         0xff, 0xff, 0xff, 0xff, 0x80, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
//         0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0xa4, 0xff, 0xff, 0xff, 0x04, 0x00, 0x00, 0x00, 0x05,
//         0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00,
//         0x64, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x18, 0x00, 0x08, 0x00, 0x06,
//         0x00, 0x07, 0x00, 0x0c, 0x00, 0x10, 0x00, 0x14, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x01, 0x05, 0x14, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x64, 0x69, 0x63, 0x74,
//         0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0xff, 0xff, 0xff, 0x00, 0x00,
//         0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0xd4, 0xff, 0xff, 0xff, 0x68, 0xff, 0xff, 0xff, 0x00,
//         0x00, 0x01, 0x06, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x62, 0x6f, 0x6f, 0x6c, 0x5f, 0x63, 0x6f,
//         0x6c, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x98, 0xff,
//         0xff, 0xff, 0x00, 0x00, 0x01, 0x03, 0x10, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x66, 0x6c, 0x6f, 0x61,
//         0x74, 0x36, 0x34, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0xce, 0xff, 0xff, 0xff, 0x00, 0x00, 0x02,
//         0x00, 0xc8, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00,
//         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x66,
//         0x6c, 0x6f, 0x61, 0x74, 0x33, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x06, 0x00,
//         0x08, 0x00, 0x06, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x14,
//         0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x74, 0x36,
//         0x34, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x07,
//         0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xa8, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x0c, 0x00, 0x14, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00,
//         0x0c, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00,
//         0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x04,
//         0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
//         0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x13,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x62, 0x65, 0x74,
//         0x61, 0x67, 0x61, 0x6d, 0x6d, 0x61, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0xff, 0xff, 0xff, 0xff, 0x48, 0x01, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x0c, 0x00, 0x16, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x0c,
//         0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x04, 0x00, 0x08,
//         0x00, 0x0a, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x07, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
//         0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe4, 0x0b, 0x54, 0x02, 0x00, 0x00, 0x00,
//         0x00, 0x1c, 0xf4, 0xab, 0xfd, 0xff, 0xff, 0xff, 0x14, 0x1a, 0x99, 0xbe, 0x1c, 0x00, 0x00,
//         0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x78, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0xfc, 0xff, 0xff, 0xff,
//         0xff, 0xff, 0xff, 0xc3, 0xf5, 0x48, 0x40, 0x00, 0x00, 0xc0, 0x7f, 0xa4, 0x70, 0x2d, 0xc0,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x42, 0x00, 0xd0, 0x79, 0xc4, 0x00, 0x00, 0xa0,
//         0x3f, 0x00, 0x00, 0x00, 0x00, 0x7d, 0xc3, 0x94, 0x25, 0xad, 0x49, 0xb2, 0x54, 0x30, 0x05,
//         0x8e, 0xe4, 0x2e, 0xff, 0x2b, 0xab, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x44, 0x8b, 0x6c, 0xe7, 0xfb, 0xa9, 0x0a, 0xc0,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3f, 0x14, 0xae, 0x47, 0xe1, 0x7a, 0x14, 0x1f,
//         0x40, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
//         0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
//         0x00, 0x00, 0x00, 0x00
//     ];

//     const ARROW_COMPLEX_FILE: &[u8] = &[
//         0x41, 0x52, 0x52, 0x4f, 0x57, 0x31, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x80, 0x01, 0x00,
//         0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00,
//         0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0xa4,
//         0xff, 0xff, 0xff, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00,
//         0xcc, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
//         0x00, 0x10, 0x00, 0x18, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x10, 0x00,
//         0x14, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x14, 0x00, 0x00, 0x00, 0x3c,
//         0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x08, 0x00, 0x00, 0x00, 0x64, 0x69, 0x63, 0x74, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00,
//         0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00,
//         0x00, 0x00, 0x20, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0xd4,
//         0xff, 0xff, 0xff, 0x68, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x06, 0x10, 0x00, 0x00, 0x00,
//         0x20, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
//         0x00, 0x62, 0x6f, 0x6f, 0x6c, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
//         0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x98, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x03, 0x10,
//         0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x0b, 0x00, 0x00, 0x00, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x36, 0x34, 0x5f, 0x63, 0x6f, 0x6c,
//         0x00, 0xce, 0xff, 0xff, 0xff, 0x00, 0x00, 0x02, 0x00, 0xc8, 0xff, 0xff, 0xff, 0x00, 0x00,
//         0x01, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x33, 0x32, 0x5f,
//         0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00, 0x06, 0x00, 0x06, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x14, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00,
//         0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x10,
//         0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x09, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00,
//         0x00, 0x08, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xa8,
//         0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x14, 0x00,
//         0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04,
//         0x00, 0x14, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
//         0x0a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00,
//         0x4c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09,
//         0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x61, 0x6c, 0x70, 0x68, 0x61, 0x62, 0x65, 0x74, 0x61, 0x67, 0x61, 0x6d, 0x6d, 0x61, 0x64,
//         0x65, 0x6c, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x48, 0x01,
//         0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x16, 0x00, 0x06,
//         0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00,
//         0x18, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
//         0x00, 0x18, 0x00, 0x0c, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0xbc, 0x00,
//         0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0xe4, 0x0b, 0x54, 0x02, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xf4, 0xab, 0xfd, 0xff, 0xff,
//         0xff, 0x14, 0x1a, 0x99, 0xbe, 0x1c, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//         0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x03, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x88, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xf5, 0x48, 0x40,
//         0x00, 0x00, 0xc0, 0x7f, 0xa4, 0x70, 0x2d, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28,
//         0x42, 0x00, 0xd0, 0x79, 0xc4, 0x00, 0x00, 0xa0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7d, 0xc3,
//         0x94, 0x25, 0xad, 0x49, 0xb2, 0x54, 0x30, 0x05, 0x8e, 0xe4, 0x2e, 0xff, 0x2b, 0xab, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
//         0x44, 0x8b, 0x6c, 0xe7, 0xfb, 0xa9, 0x0a, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
//         0x3f, 0x14, 0xae, 0x47, 0xe1, 0x7a, 0x14, 0x1f, 0x40, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
//         0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
//         0x00, 0x0c, 0x00, 0x14, 0x00, 0x06, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x10, 0x00, 0x0c, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x48, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x70, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x50, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0xa4, 0xff, 0xff, 0xff, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
//         0x18, 0x01, 0x00, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
//         0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x18, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00,
//         0x0c, 0x00, 0x10, 0x00, 0x14, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x14,
//         0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x64, 0x69, 0x63, 0x74, 0x5f, 0x63, 0x6f,
//         0x6c, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00,
//         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x20,
//         0x00, 0x00, 0x00, 0xd4, 0xff, 0xff, 0xff, 0x68, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x06,
//         0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x08, 0x00, 0x00, 0x00, 0x62, 0x6f, 0x6f, 0x6c, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00,
//         0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x98, 0xff, 0xff, 0xff, 0x00,
//         0x00, 0x01, 0x03, 0x10, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x36, 0x34,
//         0x5f, 0x63, 0x6f, 0x6c, 0x00, 0xce, 0xff, 0xff, 0xff, 0x00, 0x00, 0x02, 0x00, 0xc8, 0xff,
//         0xff, 0xff, 0x00, 0x00, 0x01, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x66, 0x6c, 0x6f, 0x61,
//         0x74, 0x33, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00, 0x06,
//         0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x14, 0x00, 0x08, 0x00,
//         0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x63,
//         0x6f, 0x6c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x07, 0x00, 0x08, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x41,
//         0x52, 0x52, 0x4f, 0x57, 0x31
//     ];

//     #[test]
//     fn test_decode_complex_stream_from_reference_arrow() {
//         let reference_stream_bytes: &[u8] = ARROW_COMPLEX_STREAM;
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::Stream);
//         let mut offset = 0;
//         let mut num_frames = 0;
//         while offset < reference_stream_bytes.len() {
//             match decoder.decode(&reference_stream_bytes[offset..]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => {
//                     assert!(frame.message.len() > 0);
//                     offset += consumed;
//                     num_frames += 1;
//                 }
//                 DecodeResult::NeedMore => break
//             }
//         }
//         assert!(num_frames >= 2);
//     }

//     #[test]
//     fn test_decode_complex_file_from_reference_arrow() {
//         let reference_file_bytes: &[u8] = ARROW_COMPLEX_FILE;
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::File);
//         let mut offset = 0;
//         let mut num_frames = 0;
//         while offset < reference_file_bytes.len() {
//             match decoder.decode(&reference_file_bytes[offset..]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => {
//                     assert!(frame.message.len() > 0);
//                     offset += consumed;
//                     num_frames += 1;
//                 }
//                 DecodeResult::NeedMore => break
//             }
//         }
//         assert!(num_frames >= 2);
//     }

//     // Datetime
//     //
//     // ```python
//     // import pyarrow as pa
//     // import pyarrow.ipc
//     // import numpy as np
//     // import datetime
//     //
//     // # All arrays length 7
//     // datetime_data = [
//     //     datetime.datetime(2024, 7, 1, 8, 0, 0, tzinfo=datetime.timezone.utc),
//     //     datetime.datetime(2024, 7, 2, 10, 30, 0, tzinfo=datetime.timezone.utc),
//     //     datetime.datetime(2024, 7, 3, 17, 45, 0, tzinfo=datetime.timezone.utc),
//     //     datetime.datetime(2024, 7, 4, 12, 15, 0, tzinfo=datetime.timezone.utc),
//     //     datetime.datetime(2025, 1, 1, 0, 0, 0, tzinfo=datetime.timezone.utc),
//     //     datetime.datetime(2038, 1, 19, 3, 14, 7, tzinfo=datetime.timezone.utc),
//     //     datetime.datetime(1999, 12, 31, 23, 59, 59, tzinfo=datetime.timezone.utc),
//     // ]
//     // datetime_array = pa.array(datetime_data, type=pa.timestamp('ms', tz='UTC'))
//     //
//     // schema = pa.schema([
//     //     ('datetime_col', pa.timestamp('ms', tz='UTC'))
//     // ])
//     //
//     // batch = pa.record_batch([
//     //     datetime_array
//     // ], schema=schema)
//     //
//     // # Write stream format (.arrows)
//     // with open("arrow_complex_stream.arrows", "wb") as f:
//     //     with pa.ipc.new_stream(f, schema) as writer:
//     //         writer.write_batch(batch)
//     //
//     // # Write file format (.arrow)
//     // with open("arrow_complex_file.arrow", "wb") as f:
//     //     with pa.ipc.new_file(f, schema) as writer:
//     //         writer.write_batch(batch)
//     //
//     // # Print Rust consts for embedding
//     // with open("arrow_complex_stream.arrows", "rb") as f:
//     //     stream_bytes = f.read()
//     // print("COMPLEX STREAM FORMAT (for Rust):\nconst ARROW_COMPLEX_STREAM: &[u8] = &[\n    {} \n];"
//     //     .format(', '.join(f'0x{b:02x}' for b in stream_bytes)))
//     //
//     // with open("arrow_complex_file.arrow", "rb") as f:
//     //     file_bytes = f.read()
//     // print("COMPLEX FILE FORMAT (for Rust):\nconst ARROW_COMPLEX_FILE: &[u8] = &[\n    {} \n];"
//     //     .format(', '.join(f'0x{b:02x}' for b in file_bytes)))
//     // ```

//     const ARROW_DATETIME_STREAM: &[u8] = &[
//         0xff, 0xff, 0xff, 0xff, 0x90, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
//         0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08,
//         0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
//         0x10, 0x00, 0x14, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10,
//         0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0a, 0x10, 0x00, 0x00, 0x00, 0x28, 0x00,
//         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x64,
//         0x61, 0x74, 0x65, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00,
//         0x08, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x55, 0x54, 0x43, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x88, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x0c, 0x00, 0x16, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00,
//         0x0c, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x04, 0x00,
//         0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x07,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x4e, 0x6d,
//         0x90, 0x01, 0x00, 0x00, 0x40, 0x80, 0xfe, 0x72, 0x90, 0x01, 0x00, 0x00, 0x60, 0x1d, 0xb3,
//         0x79, 0x90, 0x01, 0x00, 0x00, 0xa0, 0x59, 0xab, 0x7d, 0x90, 0x01, 0x00, 0x00, 0x00, 0x7c,
//         0x29, 0x1f, 0x94, 0x01, 0x00, 0x00, 0x18, 0xfc, 0xff, 0xff, 0xf3, 0x01, 0x00, 0x00, 0x18,
//         0xa8, 0xcf, 0x6a, 0xdc, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
//     ];

//     const ARROW_DATETIME_FILE: &[u8] = &[
//         0x41, 0x52, 0x52, 0x4f, 0x57, 0x31, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x90, 0x00, 0x00,
//         0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00,
//         0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x08,
//         0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
//         0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00, 0x08, 0x00, 0x06,
//         0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x01, 0x0a, 0x10, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x65, 0x74, 0x69, 0x6d, 0x65,
//         0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x08,
//         0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00,
//         0x00, 0x00, 0x55, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x88,
//         0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x16, 0x00,
//         0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04,
//         0x00, 0x18, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x3c,
//         0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x4e, 0x6d, 0x90, 0x01, 0x00, 0x00, 0x40, 0x80, 0xfe,
//         0x72, 0x90, 0x01, 0x00, 0x00, 0x60, 0x1d, 0xb3, 0x79, 0x90, 0x01, 0x00, 0x00, 0xa0, 0x59,
//         0xab, 0x7d, 0x90, 0x01, 0x00, 0x00, 0x00, 0x7c, 0x29, 0x1f, 0x94, 0x01, 0x00, 0x00, 0x18,
//         0xfc, 0xff, 0xff, 0xf3, 0x01, 0x00, 0x00, 0x18, 0xa8, 0xcf, 0x6a, 0xdc, 0x00, 0x00, 0x00,
//         0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x14,
//         0x00, 0x06, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x04, 0x00, 0x38, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01,
//         0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00,
//         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10,
//         0x00, 0x14, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00,
//         0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0a, 0x10, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00,
//         0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x64, 0x61,
//         0x74, 0x65, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x08,
//         0x00, 0x0c, 0x00, 0x06, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
//         0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x55, 0x54, 0x43, 0x00, 0xb8, 0x00, 0x00,
//         0x00, 0x41, 0x52, 0x52, 0x4f, 0x57, 0x31
//     ];

//     #[test]
//     fn test_decode_datetime_stream_from_reference_arrow() {
//         let reference_stream_bytes: &[u8] = ARROW_DATETIME_STREAM;
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::Stream);
//         let mut offset = 0;
//         let mut num_frames = 0;
//         while offset < reference_stream_bytes.len() {
//             match decoder.decode(&reference_stream_bytes[offset..]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => {
//                     assert!(frame.message.len() > 0);
//                     offset += consumed;
//                     num_frames += 1;
//                 }
//                 DecodeResult::NeedMore => break
//             }
//         }
//         assert!(num_frames >= 2);
//     }

//     #[test]
//     fn test_decode_datetime_file_from_reference_arrow() {
//         let reference_file_bytes: &[u8] = ARROW_DATETIME_FILE;
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::File);
//         let mut offset = 0;
//         let mut num_frames = 0;
//         while offset < reference_file_bytes.len() {
//             match decoder.decode(&reference_file_bytes[offset..]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => {
//                     assert!(frame.message.len() > 0);
//                     offset += consumed;
//                     num_frames += 1;
//                 }
//                 DecodeResult::NeedMore => break
//             }
//         }
//         assert!(num_frames >= 2);
//     }

//     fn build_minimal_schema_message() -> Vec<u8> {
//         let mut fbb = FlatBufferBuilder::new();

//         // Example: one int32 field called "f0"
//         let name = fbb.create_string("f0");
//         let int_type = fb::Int::create(&mut fbb, &fb::IntArgs { bitWidth: 32, is_signed: true });

//         let field = fb::Field::create(
//             &mut fbb,
//             &fb::FieldArgs {
//                 name: Some(name),
//                 nullable: true,
//                 type_type: fb::Type::Int,
//                 type_: Some(int_type.as_union_value()),
//                 dictionary: None,
//                 children: None,
//                 custom_metadata: None
//             }
//         );

//         let fields = fbb.create_vector(&[field]);

//         let schema = fb::Schema::create(
//             &mut fbb,
//             &fb::SchemaArgs {
//                 endianness: fb::Endianness::Little,
//                 fields: Some(fields),
//                 custom_metadata: None,
//                 features: None
//             }
//         );

//         let msg = fb::Message::create(
//             &mut fbb,
//             &fb::MessageArgs {
//                 version: fb::MetadataVersion::V5,
//                 header_type: fb::MessageHeader::Schema,
//                 header: Some(schema.as_union_value()),
//                 bodyLength: 0,
//                 custom_metadata: None
//             }
//         );

//         fbb.finish(msg, None);
//         fbb.finished_data().to_vec()
//     }

//     fn build_record_batch_message(n_values: usize) -> (Vec<u8>, Vec<u8>) {
//         let mut fbb = FlatBufferBuilder::new();

//         // Create a single column (Int32 array) for n_values.
//         let data: Vec<i32> = (0..n_values as i32).collect();
//         let data_bytes: &[u8] =
//             unsafe { std::slice::from_raw_parts(data.as_ptr() as *const u8, n_values * 4) };
//         // No nulls, so null_count = 0, length = n_values
//         let field_node = fb::FieldNode::new(n_values as i64, 0);
//         let field_nodes = fbb.create_vector(&[field_node]);
//         let buffers = [
//             fb::Buffer::new(0, 0),                     // Null buffer (not used)
//             fb::Buffer::new(0, (n_values * 4) as i64)  // Data buffer (follows)
//         ];
//         let buffers_vec = fbb.create_vector(&buffers);

//         let rec_batch = fb::RecordBatch::create(
//             &mut fbb,
//             &fb::RecordBatchArgs {
//                 length: n_values as i64,
//                 nodes: Some(field_nodes),
//                 buffers: Some(buffers_vec),
//                 compression: None,
//                 variadicBufferCounts: None
//             }
//         );

//         let msg = fb::Message::create(
//             &mut fbb,
//             &fb::MessageArgs {
//                 version: fb::MetadataVersion::V5,
//                 header_type: fb::MessageHeader::RecordBatch,
//                 header: Some(rec_batch.as_union_value()),
//                 bodyLength: (n_values * 4) as i64,
//                 custom_metadata: None
//             }
//         );

//         fbb.finish(msg, None);
//         (fbb.finished_data().to_vec(), data_bytes.to_vec())
//     }

//     #[test]
//     fn test_decode_stream_schema_and_batch() {
//         // Build a real Arrow schema message and record batch
//         let schema_msg = build_minimal_schema_message();
//         let (batch_msg, batch_body) = build_record_batch_message(4);

//         // Encode both as Arrow IPC frames using canonical framer (with continuation)
//         let schema_frame = ArrowIPCEncoder::encode_frame(
//             &schema_msg,
//             &[],
//             IPCMessageProtocol::Stream,
//             false,
//             false,
//             None
//         );
//         let batch_frame = ArrowIPCEncoder::encode_frame(
//             &batch_msg,
//             &batch_body,
//             IPCMessageProtocol::Stream,
//             false,
//             false,
//             None
//         );

//         // Concatenate frames as a byte stream
//         let mut stream_bytes = Vec::new();
//         stream_bytes.extend_from_slice(&schema_frame);
//         stream_bytes.extend_from_slice(&batch_frame);

//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::Stream);

//         // Decode schema frame
//         let result = decoder.decode(&stream_bytes[..schema_frame.len()]).unwrap();
//         match result {
//             DecodeResult::Frame { frame, consumed } => {
//                 assert_eq!(frame.message.as_slice(), &schema_msg[..]);
//                 assert!(frame.body.is_empty());
//                 assert_eq!(consumed, schema_frame.len());
//             }
//             _ => panic!("Expected schema frame")
//         }

//         // Decode batch frame (offset by schema frame length)
//         let result = decoder.decode(&stream_bytes[schema_frame.len()..]).unwrap();
//         match result {
//             DecodeResult::Frame { frame, consumed } => {
//                 assert_eq!(frame.message.as_slice(), &batch_msg[..]);
//                 assert_eq!(frame.body.as_slice(), &batch_body[..]);
//                 assert_eq!(consumed, batch_frame.len());
//             }
//             _ => panic!("Expected record batch frame")
//         }
//     }

//     #[test]
//     fn test_decode_file_schema_batch_footer() {
//         // Build schema, batch, and footer messages
//         let schema_msg = build_minimal_schema_message();
//         let (batch_msg, batch_body) = build_record_batch_message(2);

//         let footer: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8];

//         let schema_frame = ArrowIPCEncoder::encode_frame(
//             &schema_msg,
//             &[],
//             IPCMessageProtocol::File,
//             true,
//             false,
//             None
//         );
//         let batch_frame = ArrowIPCEncoder::encode_frame(
//             &batch_msg,
//             &batch_body,
//             IPCMessageProtocol::File,
//             false,
//             false,
//             None
//         );
//         let last_frame = ArrowIPCEncoder::encode_frame(
//             &batch_msg,
//             &batch_body,
//             IPCMessageProtocol::File,
//             false,
//             true,
//             Some(&footer)
//         );

//         let mut file_bytes = Vec::new();
//         file_bytes.extend_from_slice(&schema_frame);
//         file_bytes.extend_from_slice(&batch_frame);
//         file_bytes.extend_from_slice(&last_frame);

//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::File);

//         // Schema
//         let (frame, consumed) = match decoder.decode(&file_bytes[..schema_frame.len()]).unwrap() {
//             DecodeResult::Frame { frame, consumed } => (frame, consumed),
//             _ => panic!("Expected schema frame")
//         };
//         assert_eq!(frame.message.as_slice(), &schema_msg[..]);
//         assert!(frame.body.is_empty());
//         assert_eq!(consumed, schema_frame.len());

//         // Batch
//         let offset = schema_frame.len();
//         let (frame, consumed) =
//             match decoder.decode(&file_bytes[offset..offset + batch_frame.len()]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => (frame, consumed),
//                 _ => panic!("Expected batch frame")
//             };
//         assert_eq!(frame.message.as_slice(), &batch_msg[..]);
//         assert_eq!(frame.body.as_slice(), &batch_body[..]);
//         assert_eq!(consumed, batch_frame.len());

//         // Last frame (batch + footer + magic)
//         let offset2 = offset + batch_frame.len();
//         let rest = &file_bytes[offset2..];

//         match decoder.decode(rest).unwrap() {
//             DecodeResult::Frame { frame, consumed } => {
//                 assert_eq!(frame.message.as_slice(), &batch_msg[..]);
//                 assert_eq!(frame.body.as_slice(), &batch_body[..]);

//                 // Footer+magic is processed next
//                 let rest2 = &rest[consumed..];
//                 let footer_result = decoder.decode(rest2).unwrap();
//                 match footer_result {
//                     DecodeResult::NeedMore => (), // Done
//                     _ => panic!("Expected need more (footer end)")
//                 }

//                 let expected_len = last_frame.len();
//                 assert_eq!(consumed + rest2.len(), expected_len);
//             }
//             _ => panic!("Expected last batch+footer frame")
//         }
//     }

//     #[test]
//     fn test_decode_with_partial_chunks() {
//         // Build schema message and record batch
//         let schema_msg = build_minimal_schema_message();
//         let (batch_msg, batch_body) = build_record_batch_message(1);

//         let schema_frame = ArrowIPCEncoder::encode_frame(
//             &schema_msg,
//             &[],
//             IPCMessageProtocol::Stream,
//             false,
//             false,
//             None
//         );
//         let batch_frame = ArrowIPCEncoder::encode_frame(
//             &batch_msg,
//             &batch_body,
//             IPCMessageProtocol::Stream,
//             false,
//             false,
//             None
//         );

//         // Interleave and fragment the stream into small chunks
//         let mut stream_bytes = Vec::new();
//         stream_bytes.extend_from_slice(&schema_frame);
//         stream_bytes.extend_from_slice(&batch_frame);

//         // Feed chunks incrementally to test decoder "NeedMore"
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::Stream);

//         // Schema frame by small increments
//         for chunk in 1..schema_frame.len() {
//             let partial = &stream_bytes[..chunk];
//             let result = decoder.decode(partial);
//             if chunk < schema_frame.len() {
//                 assert!(matches!(result, Ok(DecodeResult::NeedMore)));
//             }
//         }
//         // Full decode after complete schema frame
//         let result = decoder.decode(&stream_bytes[..schema_frame.len()]).unwrap();
//         assert!(matches!(result, DecodeResult::Frame { .. }));

//         // Batch frame in increments
//         let offset = schema_frame.len();
//         for chunk in 1..batch_frame.len() {
//             let partial = &stream_bytes[offset..offset + chunk];
//             let result = decoder.decode(partial);
//             if chunk < batch_frame.len() {
//                 assert!(matches!(result, Ok(DecodeResult::NeedMore)));
//             }
//         }
//         let result = decoder.decode(&stream_bytes[offset..offset + batch_frame.len()]).unwrap();
//         assert!(matches!(result, DecodeResult::Frame { .. }));
//     }

//     #[test]
//     fn test_decode_file_schema_batch_footer_in_fragments() {
//         // Build schema, batch, and footer messages
//         let schema_msg = build_minimal_schema_message();
//         let (batch_msg, batch_body) = build_record_batch_message(2);

//         let footer: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8];

//         let schema_frame = ArrowIPCEncoder::encode_frame(
//             &schema_msg,
//             &[],
//             IPCMessageProtocol::File,
//             true,
//             false,
//             None
//         );
//         let batch_frame = ArrowIPCEncoder::encode_frame(
//             &batch_msg,
//             &batch_body,
//             IPCMessageProtocol::File,
//             false,
//             false,
//             None
//         );
//         let last_frame = ArrowIPCEncoder::encode_frame(
//             &batch_msg,
//             &batch_body,
//             IPCMessageProtocol::File,
//             false,
//             true,
//             Some(&footer)
//         );

//         // Get the full bytes of the file including footer and magic
//         let mut file_bytes = Vec::new();
//         file_bytes.extend_from_slice(&schema_frame);
//         file_bytes.extend_from_slice(&batch_frame);
//         file_bytes.extend_from_slice(&last_frame);

//         // Offset of last_frame within the total buffer
//         let offset2 = schema_frame.len() + batch_frame.len();
//         let last_bytes = &file_bytes[offset2..];

//         // Fragment the last frame, footer, and magic into small pieces
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::File);

//         // Decode schema
//         let result = decoder.decode(&file_bytes[..schema_frame.len()]).unwrap();
//         match result {
//             DecodeResult::Frame { frame, consumed: _ } => {
//                 assert_eq!(frame.message.as_slice(), &schema_msg[..]);
//                 assert!(frame.body.is_empty());
//             }
//             _ => panic!("Expected schema frame")
//         }

//         // Decode batch
//         let offset = schema_frame.len();
//         let result = decoder.decode(&file_bytes[offset..offset + batch_frame.len()]).unwrap();
//         match result {
//             DecodeResult::Frame { frame, consumed: _ } => {
//                 assert_eq!(frame.message.as_slice(), &batch_msg[..]);
//                 assert_eq!(frame.body.as_slice(), &batch_body[..]);
//             }
//             _ => panic!("Expected batch frame")
//         }

//         // Decode last frame and then footer/magic in fragments
//         // Find the length of the record batch part in last_frame (excluding footer/magic)
//         let record_batch_len = last_frame.len() - (footer.len() + 4 + 8);
//         let record_batch_bytes = &last_bytes[..record_batch_len];

//         // 1. Feed just the record batch part
//         let result = decoder.decode(record_batch_bytes).unwrap();
//         match result {
//             DecodeResult::Frame { frame, consumed: _ } => {
//                 assert_eq!(frame.message.as_slice(), &batch_msg[..]);
//                 assert_eq!(frame.body.as_slice(), &batch_body[..]);
//             }
//             _ => panic!("Expected last record batch frame")
//         }

//         // 2. Feed the footer and magic one byte at a time, expect NeedMore until all is present
//         let tail_bytes = &last_bytes[record_batch_len..];
//         let mut acc = Vec::new();
//         for (i, b) in tail_bytes.iter().enumerate() {
//             acc.push(*b);
//             let result = decoder.decode(&acc);
//             if i < tail_bytes.len() - 1 {
//                 assert!(
//                     matches!(result, Ok(DecodeResult::NeedMore)),
//                     "Expected NeedMore for tail fragment of length {}",
//                     acc.len()
//                 );
//             } else {
//                 // After final byte, should be fully consumed and in Done state (no frame to emit)
//                 assert!(
//                     matches!(result, Ok(DecodeResult::NeedMore)),
//                     "Expected NeedMore after full footer+magic"
//                 );
//                 assert!(matches!(decoder.state, DecodeState::Done));
//             }
//         }
//     }
// }
