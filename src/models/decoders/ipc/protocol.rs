//! Arrow IPC Frame Decoder
//!
//! Decodes Arrow IPC (Inter-Process Communication) frames for both *file* and *stream* protocols,
//! as defined by the official [Apache Arrow Columnar IPC specification](https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format).
//!
//! # Overview
//!
//! - **File protocol**: bounded, random-access, with header magic, aligned frames, and trailing magic/footer.
//! - **Stream protocol**: unbounded, emits 8-byte continuation markers before messages (or legacy 4-byte length without marker).
//!
//! The decoder works as a state machine, consuming input buffers and producing `ArrowIPCMessage` instances as complete frames are detected.

use std::io;
use std::marker::PhantomData;

use crate::constants::{
    ARROW_MAGIC_NUMBER, ARROW_MAGIC_NUMBER_PADDED, CONTINUATION_MARKER_LEN, CONTINUATION_SENTINEL,
    FILE_CLOSING_MAGIC_LEN, FILE_OPENING_MAGIC_LEN, METADATA_SIZE_PREFIX,
};
use crate::enums::{DecodeResult, DecodeState, IPCMessageProtocol};
use crate::models::frames::ipc_message::ArrowIPCMessage;
use crate::traits::frame_decoder::FrameDecoder;
use crate::traits::stream_buffer::StreamBuffer;
use crate::utils::align_8;

/// Decoder for Arrow IPC (file/stream) format state machine.
pub struct ArrowIPCFrameDecoder<B: StreamBuffer> {
    format: IPCMessageProtocol,
    state: DecodeState<B>,
    /// Bytes of *prefix* that precede the flatbuffer message for the *current* frame:
    /// - STREAM: 4 (length) or 8 (marker + length)
    /// - FILE: always 4 (length)
    pending_prefix_len: usize,
    /// True until we have *accounted for* the initial 8-byte file magic
    /// by including it in the `consumed` count of the first FILE frame.
    file_magic_unconsumed: bool,
    _phantom: PhantomData<B>,
}

impl<B: StreamBuffer> FrameDecoder for ArrowIPCFrameDecoder<B> {
    type Frame = ArrowIPCMessage<B>;

    fn decode(&mut self, buf: &[u8]) -> io::Result<DecodeResult<Self::Frame>> {
        loop {
            // Auto-detect File magic at head in "Stream" mode (some writers do this).
            if matches!(self.state, DecodeState::Initial)
                && matches!(self.format, IPCMessageProtocol::Stream)
                && Self::has_opening_file_magic(buf)
            {
                self.format = IPCMessageProtocol::File;
                self.file_magic_unconsumed = true;
                self.state = DecodeState::ReadingMessageLength;
                // continue within same buffer
            }

            let state = std::mem::replace(&mut self.state, DecodeState::Initial);
            let step = match state {
                DecodeState::Initial => self.decode_initial(buf)?,
                DecodeState::ReadingContinuationSize { .. } => {
                    // We don’t use this state anymore; keep compatibility by re-routing.
                    self.state = DecodeState::ReadingMessageLength;
                    None
                }
                DecodeState::ReadingMessageLength => self.decode_message_length(buf)?,
                DecodeState::ReadingMessage { msg_len } => self.decode_message(buf, msg_len)?,
                DecodeState::ReadingBody { body_len, message } => {
                    self.decode_body(buf, body_len, message)?
                }
                DecodeState::ReadingFooter {
                    footer_len,
                    footer_offset,
                } => self.decode_footer(buf, footer_len, footer_offset)?,
                DecodeState::Done => Some(DecodeResult::NeedMore),
                DecodeState::AfterMagic => {
                    // The first FILE frame must still count the 8-byte magic in `consumed`.
                    // We do not consume/emit here; just proceed to read the first length.
                    self.state = DecodeState::ReadingMessageLength;
                    None
                }
                DecodeState::AfterContMarker => {
                    // Not used; STREAM markers are handled via `pending_prefix_len`.
                    self.state = DecodeState::ReadingMessageLength;
                    None
                }
            };

            if let Some(done) = step {
                return Ok(done);
            }
            // otherwise loop and continue progressing within the same input slice
        }
    }
}

impl<B: StreamBuffer> ArrowIPCFrameDecoder<B> {
    pub fn new(format: IPCMessageProtocol) -> Self {
        Self {
            format,
            state: DecodeState::Initial,
            pending_prefix_len: 0,
            file_magic_unconsumed: matches!(format, IPCMessageProtocol::File),
            _phantom: PhantomData,
        }
    }

    /// Construct a decoder that skips file magic validation/consumption.
    pub fn new_without_header_check(format: IPCMessageProtocol) -> Self {
        Self {
            format,
            state: if format == IPCMessageProtocol::File {
                DecodeState::ReadingMessageLength
            } else {
                DecodeState::Initial
            },
            pending_prefix_len: 0,
            file_magic_unconsumed: false,
            _phantom: PhantomData,
        }
    }

    #[inline]
    fn read_u32_le(buf: &[u8]) -> u32 {
        u32::from_le_bytes(buf[..4].try_into().unwrap())
    }

    #[inline]
    fn has_opening_file_magic(buf: &[u8]) -> bool {
        buf.len() >= FILE_OPENING_MAGIC_LEN && &buf[..FILE_OPENING_MAGIC_LEN] == ARROW_MAGIC_NUMBER_PADDED
    }

    #[inline]
    fn has_continuation_sentinel(buf: &[u8]) -> bool {
        buf.len() >= METADATA_SIZE_PREFIX && Self::read_u32_le(buf) == CONTINUATION_SENTINEL
    }

    #[inline]
    fn has_eos_marker(buf: &[u8]) -> bool {
        buf.len() >= 8
            && Self::read_u32_le(&buf[0..4]) == 0xFFFF_FFFF
            && Self::read_u32_le(&buf[4..8]) == 0x0000_0000
    }

    #[inline]
    fn has_file_footer_markers(buf: &[u8], len_off: usize, msg_len: usize) -> bool {
        // After the (u32) length and `msg_len` bytes, the trailing magic must fit.
        msg_len > 0 && len_off + METADATA_SIZE_PREFIX + msg_len + FILE_OPENING_MAGIC_LEN <= buf.len()
    }

    /// For the *current* frame, return 8 only if FILE and header has not been counted yet.
    #[inline]
    fn current_base_offset(&self) -> usize {
        if self.format == IPCMessageProtocol::File && self.file_magic_unconsumed {
            FILE_OPENING_MAGIC_LEN
        } else {
            0
        }
    }

    /// Handles initial protocol-specific header detection (magic or marker).
    #[inline]
    fn decode_initial(
        &mut self,
        buf: &[u8],
    ) -> io::Result<Option<DecodeResult<ArrowIPCMessage<B>>>> {
        match self.format {
            IPCMessageProtocol::File => {
                // Validate header; do NOT mark it consumed yet. We’ll include +8 in the first frame’s `consumed`.
                if buf.len() < FILE_OPENING_MAGIC_LEN {
                    return Ok(Some(DecodeResult::NeedMore));
                }
                if !Self::has_opening_file_magic(buf) {
                    return Err(io::Error::new(
                        io::ErrorKind::InvalidData,
                        "Invalid Arrow file magic header",
                    ));
                }
                self.state = DecodeState::AfterMagic;
                // Continue within same buffer
            }
            IPCMessageProtocol::Stream => {
                // EOS at start?
                if Self::has_eos_marker(buf) {
                    return Ok(Some(DecodeResult::Frame {
                        frame: ArrowIPCMessage {
                            message: B::default(),
                            body: B::default(),
                        },
                        consumed: 8,
                    }));
                }

                // Continuation marker present?
                if Self::has_continuation_sentinel(buf) {
                    self.pending_prefix_len = 8; // marker (4) + length (4)
                } else {
                    self.pending_prefix_len = 4; // legacy stream: just a 4-byte length
                }
                self.state = DecodeState::ReadingMessageLength;
            }
        }
        Ok(None)
    }

    /// Handles parsing the length prefix for the next Arrow IPC message.
    fn decode_message_length(
        &mut self,
        buf: &[u8],
    ) -> io::Result<Option<DecodeResult<ArrowIPCMessage<B>>>> {
        let base_off = self.current_base_offset();

        // STREAM: handle EOS/marker at (base_off == 0)
        if self.format == IPCMessageProtocol::Stream {
            if buf.len() >= base_off + 8 && Self::has_eos_marker(&buf[base_off..]) {
                return Ok(Some(DecodeResult::Frame {
                    frame: ArrowIPCMessage { message: B::default(), body: B::default() },
                    consumed: base_off + 8, // normally 8
                }));
            }

            let has_marker = buf.len() >= base_off + 4
                && Self::has_continuation_sentinel(&buf[base_off..]);

            let len_off = base_off + if has_marker { 4 } else { 0 };
            self.pending_prefix_len = if has_marker { 8 } else { 4 };

            if buf.len() < len_off + METADATA_SIZE_PREFIX {
                return Ok(Some(DecodeResult::NeedMore));
            }

            let msg_len =
                Self::read_u32_le(&buf[len_off..len_off + METADATA_SIZE_PREFIX]) as usize;

            // In stream mode, msg_len == 0 means EOS (with/without marker)
            if msg_len == 0 {
                return Ok(Some(DecodeResult::Frame {
                    frame: ArrowIPCMessage { message: B::default(), body: B::default() },
                    consumed: base_off + self.pending_prefix_len, // 4 or 8
                }));
            }

            self.state = DecodeState::ReadingMessage { msg_len };
            return Ok(None);
        }

        // FILE: read u32 length after (possibly) the 8-byte header on first frame
        let len_off = base_off;
        self.pending_prefix_len = METADATA_SIZE_PREFIX; // always 4 for FILE

        if buf.len() < len_off + METADATA_SIZE_PREFIX {
            return Ok(Some(DecodeResult::NeedMore));
        }

        let msg_len =
            Self::read_u32_le(&buf[len_off..len_off + METADATA_SIZE_PREFIX]) as usize;

        // Footer detection: after len+msg_len there must be trailing magic
        if Self::has_file_footer_markers(buf, len_off, msg_len) {
            let possible_magic = &buf[len_off + METADATA_SIZE_PREFIX + msg_len
                ..len_off + METADATA_SIZE_PREFIX + msg_len + FILE_OPENING_MAGIC_LEN];
            if possible_magic == ARROW_MAGIC_NUMBER {
                self.state = DecodeState::ReadingFooter {
                    footer_len: msg_len,
                    footer_offset: len_off + METADATA_SIZE_PREFIX,
                };
                return Ok(None);
            }
        }

        if msg_len == 0 {
            // In FILE mode zero-length message is invalid (not an EOS sentinel).
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "Zero-length message",
            ));
        }

        self.state = DecodeState::ReadingMessage { msg_len };
        Ok(None)
    }

    /// Decode the FB message and (if present) the body for the current frame.
    fn decode_message(
        &mut self,
        buf: &[u8],
        msg_len: usize,
    ) -> io::Result<Option<DecodeResult<ArrowIPCMessage<B>>>> {
        let base_off = self.current_base_offset();
        let prefix = self.pending_prefix_len; // 4/8 stream, 4 file

        let meta_start = base_off + prefix;
        let meta_end = meta_start + msg_len;

        if buf.len() < meta_end {
            return Ok(Some(DecodeResult::NeedMore));
        }

        let message = B::from_slice(&buf[meta_start..meta_end]);

        // Parse FB message for body length
        use flatbuffers::root;
        use crate::AFMessage;
        let root = root::<AFMessage>(&message.as_ref()).map_err(|e| {
            io::Error::new(io::ErrorKind::InvalidData, format!("Failed to parse message: {e}"))
        })?;
        let body_len = root.bodyLength() as usize;

        let meta_pad = align_8(msg_len);
        let body_start = meta_end + meta_pad;

        if body_len > 0 {
            let body_end = body_start + body_len;
            if buf.len() < body_end {
                // Need more to finish the body later; keep the message around.
                self.state = DecodeState::ReadingBody { body_len, message };
                return Ok(Some(DecodeResult::NeedMore));
            }

            let body = B::from_slice(&buf[body_start..body_end]);
            let consumed = base_off + prefix + msg_len + meta_pad + body_len;

            // Prepare for next frame
            self.state = DecodeState::ReadingMessageLength;
            self.pending_prefix_len = 0;

            // First FILE frame accounts for 8-byte magic here
            if self.file_magic_unconsumed && self.format == IPCMessageProtocol::File {
                self.file_magic_unconsumed = false;
            }

            return Ok(Some(DecodeResult::Frame {
                frame: ArrowIPCMessage { message, body },
                consumed,
            }));
        } else {
            // No body
            let consumed = base_off + prefix + msg_len + meta_pad;

            self.state = DecodeState::ReadingMessageLength;
            self.pending_prefix_len = 0;

            if self.file_magic_unconsumed && self.format == IPCMessageProtocol::File {
                self.file_magic_unconsumed = false;
            }

            let frame = ArrowIPCMessage {
                message,
                body: B::default(),
            };
            return Ok(Some(DecodeResult::Frame { frame, consumed }));
        }
    }

    /// Continue reading the body if `decode_message` determined it wasn't fully available yet.
    fn decode_body(
        &mut self,
        buf: &[u8],
        body_len: usize,
        message: B,
    ) -> io::Result<Option<DecodeResult<ArrowIPCMessage<B>>>> {
        let base_off = self.current_base_offset();
        let prefix = self.pending_prefix_len; // 4/8 stream, 4 file

        let meta_pad = align_8(message.len());
        let needed = base_off + prefix + message.len() + meta_pad + body_len;

        if buf.len() < needed {
            return Ok(Some(DecodeResult::NeedMore));
        }

        let bstart = base_off + prefix + message.len() + meta_pad;
        let bend = bstart + body_len;
        let body = B::from_slice(&buf[bstart..bend]);

        self.state = DecodeState::ReadingMessageLength;
        self.pending_prefix_len = 0;

        if self.file_magic_unconsumed && self.format == IPCMessageProtocol::File {
            self.file_magic_unconsumed = false;
        }

        Ok(Some(DecodeResult::Frame {
            frame: ArrowIPCMessage::<B> { message, body },
            consumed: needed,
        }))
    }

    /// Handles decoding of file footer and trailing magic in Arrow File protocol.
    #[inline]
    fn decode_footer(
        &mut self,
        buf: &[u8],
        footer_len: usize,
        footer_offset: usize,
    ) -> io::Result<Option<DecodeResult<ArrowIPCMessage<B>>>> {
        // Wait for footer bytes
        if buf.len() < footer_offset + footer_len {
            return Ok(Some(DecodeResult::NeedMore));
        }
        // Need the size (u32 LE) and trailing magic
        if buf.len() < footer_offset + footer_len + 4 + FILE_CLOSING_MAGIC_LEN {
            return Ok(Some(DecodeResult::NeedMore));
        }

        let size_offset = footer_offset + footer_len;
        let footer_size =
            u32::from_le_bytes(buf[size_offset..size_offset + 4].try_into().unwrap()) as usize;

        if footer_size != footer_len {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!(
                    "Arrow file footer size mismatch: expected {footer_len}, found {footer_size}"
                ),
            ));
        }

        let magic = &buf[size_offset + 4..size_offset + 4 + FILE_CLOSING_MAGIC_LEN];
        if magic != ARROW_MAGIC_NUMBER {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "Invalid Arrow file trailing magic",
            ));
        }

        self.state = DecodeState::Done;
        Ok(None)
    }
}

impl<B: StreamBuffer> Default for ArrowIPCFrameDecoder<B> {
    fn default() -> Self {
        ArrowIPCFrameDecoder::new(IPCMessageProtocol::Stream)
    }
}

// #[cfg(test)]
// mod tests {
//     use flatbuffers::FlatBufferBuilder;

//     use super::*;
//     use crate::arrow::message::org::apache::arrow::flatbuf as fb;
//     use crate::enums::IPCMessageProtocol;
//     use crate::models::encoders::ipc_encoder::ArrowIPCEncoder;

//     // Simple case
//     //
//     // ```python
//     // import pyarrow as pa
//     // import pyarrow.ipc
//     //
//     // # Define a sample Arrow schema and record batch
//     // schema = pa.schema([
//     //     ('a', pa.int32()),
//     //     ('b', pa.string())
//     // ])
//     //
//     // batch = pa.record_batch([
//     //     pa.array([1, 2, 3, 4], type=pa.int32()),
//     //     pa.array(['foo', 'bar', 'baz', 'qux'], type=pa.string())
//     // ], schema=schema)
//     //
//     // # Write stream format (.arrows)
//     // with open("arrow_reference_stream.arrows", "wb") as f:
//     //     with pa.ipc.new_stream(f, schema) as writer:
//     //         writer.write_batch(batch)
//     //
//     // # Write file format (.arrow)
//     // with open("arrow_reference_file.arrow", "wb") as f:
//     //     with pa.ipc.new_file(f, schema) as writer:
//     //         writer.write_batch(batch)
//     //
//     // # For embedding as Rust const bytes, you can do:
//     // with open("arrow_reference_stream.arrows", "rb") as f:
//     //     stream_bytes = f.read()
//     // print("STREAM FORMAT (for Rust):\nconst ARROW_REFERENCE_STREAM: &[u8] = &[\n    {} \n];"
//     //     .format(', '.join(f'0x{b:02x}' for b in stream_bytes)))
//     //
//     // with open("arrow_reference_file.arrow", "rb") as f:
//     //     file_bytes = f.read()
//     // print("FILE FORMAT (for Rust):\nconst ARROW_REFERENCE_FILE: &[u8] = &[\n    {} \n];"
//     //     .format(', '.join(f'0x{b:02x}' for b in file_bytes)))
//     //```

//     const ARROW_REFERENCE_STREAM_BASIC: &[u8] = &[
//         0xff, 0xff, 0xff, 0xff, 0xa8, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
//         0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08,
//         0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
//         0x04, 0x00, 0x00, 0x00, 0xd8, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x05, 0x10, 0x00, 0x00,
//         0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
//         0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10,
//         0x00, 0x14, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00,
//         0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00,
//         0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x61, 0x00,
//         0x00, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
//         0xc8, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x16,
//         0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x03,
//         0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00,
//         0x6c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00,
//         0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
//         0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x62, 0x61, 0x7a, 0x71, 0x75,
//         0x78, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
//     ];

//     const ARROW_REFERENCE_FILE_BASIC: &[u8] = &[
//         0x41, 0x52, 0x52, 0x4f, 0x57, 0x31, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xa8, 0x00, 0x00,
//         0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00,
//         0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x08,
//         0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
//         0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xd8, 0xff, 0xff,
//         0xff, 0x00, 0x00, 0x01, 0x05, 0x10, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00, 0x08, 0x00, 0x06, 0x00,
//         0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x02, 0x10, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x08,
//         0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x16, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00,
//         0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0x38,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00,
//         0x04, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
//         0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
//         0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
//         0x09, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f,
//         0x62, 0x61, 0x72, 0x62, 0x61, 0x7a, 0x71, 0x75, 0x78, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
//         0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x14, 0x00, 0x06,
//         0x00, 0x08, 0x00, 0x0c, 0x00, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
//         0x38, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
//         0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00,
//         0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
//         0x00, 0xd8, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x05, 0x10, 0x00, 0x00, 0x00, 0x18, 0x00,
//         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62,
//         0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00,
//         0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x04, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x08,
//         0x00, 0x0c, 0x00, 0x08, 0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x20, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x41, 0x52, 0x52, 0x4f, 0x57, 0x31
//     ];

//     #[test]
//     fn test_decode_basic_stream_from_reference_arrow() {
//         let reference_stream_bytes: &[u8] = ARROW_REFERENCE_STREAM_BASIC;
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::Stream);
//         let mut offset = 0;
//         let mut num_frames = 0;
//         while offset < reference_stream_bytes.len() {
//             match decoder.decode(&reference_stream_bytes[offset..]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => {
//                     assert!(frame.message.len() > 0);
//                     offset += consumed;
//                     num_frames += 1;
//                 }
//                 DecodeResult::NeedMore => break
//             }
//         }
//         assert!(num_frames >= 2);
//     }

//     #[test]
//     fn test_decode_basic_file_from_reference_arrow() {
//         let reference_file_bytes: &[u8] = ARROW_REFERENCE_FILE_BASIC;
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::File);
//         let mut offset = 0;
//         let mut num_frames = 0;
//         while offset < reference_file_bytes.len() {
//             println!("{:?}", decoder.decode(&reference_file_bytes[offset..]).unwrap());
//             match decoder.decode(&reference_file_bytes[offset..]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => {
//                     assert!(frame.message.len() > 0);
//                     offset += consumed;
//                     num_frames += 1;
//                 }
//                 DecodeResult::NeedMore => break
//             }
//         }
//         println!("{}", num_frames);
//         assert!(num_frames >= 2);
//     }

//     //  Complex case:
//     // ```python
//     //    import pyarrow as pa
//     //    import pyarrow.ipc
//     //    import numpy as np
//     //    import datetime
//     //
//     //    # All arrays length 7
//     //    int64_data   = [10000000000, -10000000000, 123456789012, -1, 0, 888, -888]
//     //    float32_data = [3.14, np.nan, -2.71, 0.0, 42.0, -999.25, 1.25]
//     //    float64_data = [1e100, -1e-100, 0.0, 2.0, -3.333, 1.5, 7.77]
//     //    bool_data    = [True, False, True, False, True, True, False]
//     //    labels       = pa.array(['alpha', 'beta', 'alpha', 'gamma', 'beta', 'gamma', 'delta'])
//     //    dict_type    = pa.dictionary(pa.int32(), pa.string())
//     //    dict_array   = labels.cast(dict_type)
//     //
//     //    schema = pa.schema([
//     //        ('int64_col', pa.int64()),
//     //        ('float32_col', pa.float32()),
//     //        ('float64_col', pa.float64()),
//     //        ('bool_col', pa.bool_()),
//     //        ('dict_col', dict_type),
//     //    ])
//     //
//     //    batch = pa.record_batch([
//     //        pa.array(int64_data, type=pa.int64()),
//     //        pa.array(float32_data, type=pa.float32()),
//     //        pa.array(float64_data, type=pa.float64()),
//     //        pa.array(bool_data, type=pa.bool_()),
//     //        dict_array,
//     //    ], schema=schema)
//     //
//     //    # Write stream format (.arrows)
//     //    with open("arrow_complex_stream.arrows", "wb") as f:
//     //        with pa.ipc.new_stream(f, schema) as writer:
//     //            writer.write_batch(batch)
//     //
//     //    # Write file format (.arrow)
//     //    with open("arrow_complex_file.arrow", "wb") as f:
//     //        with pa.ipc.new_file(f, schema) as writer:
//     //            writer.write_batch(batch)
//     //
//     //    # Print Rust consts for embedding
//     //    with open("arrow_complex_stream.arrows", "rb") as f:
//     //        stream_bytes = f.read()
//     //    print("COMPLEX STREAM FORMAT (for Rust):\nconst ARROW_COMPLEX_STREAM: &[u8] = &[\n    {} \n];"
//     //        .format(', '.join(f'0x{b:02x}' for b in stream_bytes)))
//     //
//     //    with open("arrow_complex_file.arrow", "rb") as f:
//     //        file_bytes = f.read()
//     //    print("COMPLEX FILE FORMAT (for Rust):\nconst ARROW_COMPLEX_FILE: &[u8] = &[\n    {} \n];"
//     //        .format(', '.join(f'0x{b:02x}' for b in file_bytes)))
//     // ```

//     const ARROW_COMPLEX_STREAM: &[u8] = &[
//         0xff, 0xff, 0xff, 0xff, 0x80, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
//         0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0xa4, 0xff, 0xff, 0xff, 0x04, 0x00, 0x00, 0x00, 0x05,
//         0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00,
//         0x64, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x18, 0x00, 0x08, 0x00, 0x06,
//         0x00, 0x07, 0x00, 0x0c, 0x00, 0x10, 0x00, 0x14, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x01, 0x05, 0x14, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x64, 0x69, 0x63, 0x74,
//         0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0xff, 0xff, 0xff, 0x00, 0x00,
//         0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0xd4, 0xff, 0xff, 0xff, 0x68, 0xff, 0xff, 0xff, 0x00,
//         0x00, 0x01, 0x06, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x62, 0x6f, 0x6f, 0x6c, 0x5f, 0x63, 0x6f,
//         0x6c, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x98, 0xff,
//         0xff, 0xff, 0x00, 0x00, 0x01, 0x03, 0x10, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x66, 0x6c, 0x6f, 0x61,
//         0x74, 0x36, 0x34, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0xce, 0xff, 0xff, 0xff, 0x00, 0x00, 0x02,
//         0x00, 0xc8, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00,
//         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x66,
//         0x6c, 0x6f, 0x61, 0x74, 0x33, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x06, 0x00,
//         0x08, 0x00, 0x06, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x14,
//         0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x74, 0x36,
//         0x34, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x07,
//         0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xa8, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x0c, 0x00, 0x14, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00,
//         0x0c, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00,
//         0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x04,
//         0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
//         0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x13,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x62, 0x65, 0x74,
//         0x61, 0x67, 0x61, 0x6d, 0x6d, 0x61, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0xff, 0xff, 0xff, 0xff, 0x48, 0x01, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x0c, 0x00, 0x16, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x0c,
//         0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x04, 0x00, 0x08,
//         0x00, 0x0a, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x07, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
//         0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe4, 0x0b, 0x54, 0x02, 0x00, 0x00, 0x00,
//         0x00, 0x1c, 0xf4, 0xab, 0xfd, 0xff, 0xff, 0xff, 0x14, 0x1a, 0x99, 0xbe, 0x1c, 0x00, 0x00,
//         0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x78, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0xfc, 0xff, 0xff, 0xff,
//         0xff, 0xff, 0xff, 0xc3, 0xf5, 0x48, 0x40, 0x00, 0x00, 0xc0, 0x7f, 0xa4, 0x70, 0x2d, 0xc0,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x42, 0x00, 0xd0, 0x79, 0xc4, 0x00, 0x00, 0xa0,
//         0x3f, 0x00, 0x00, 0x00, 0x00, 0x7d, 0xc3, 0x94, 0x25, 0xad, 0x49, 0xb2, 0x54, 0x30, 0x05,
//         0x8e, 0xe4, 0x2e, 0xff, 0x2b, 0xab, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x44, 0x8b, 0x6c, 0xe7, 0xfb, 0xa9, 0x0a, 0xc0,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3f, 0x14, 0xae, 0x47, 0xe1, 0x7a, 0x14, 0x1f,
//         0x40, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
//         0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
//         0x00, 0x00, 0x00, 0x00
//     ];

//     const ARROW_COMPLEX_FILE: &[u8] = &[
//         0x41, 0x52, 0x52, 0x4f, 0x57, 0x31, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x80, 0x01, 0x00,
//         0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00,
//         0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0xa4,
//         0xff, 0xff, 0xff, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00,
//         0xcc, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
//         0x00, 0x10, 0x00, 0x18, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x10, 0x00,
//         0x14, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x14, 0x00, 0x00, 0x00, 0x3c,
//         0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x08, 0x00, 0x00, 0x00, 0x64, 0x69, 0x63, 0x74, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00,
//         0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00,
//         0x00, 0x00, 0x20, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0xd4,
//         0xff, 0xff, 0xff, 0x68, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x06, 0x10, 0x00, 0x00, 0x00,
//         0x20, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
//         0x00, 0x62, 0x6f, 0x6f, 0x6c, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
//         0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x98, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x03, 0x10,
//         0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x0b, 0x00, 0x00, 0x00, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x36, 0x34, 0x5f, 0x63, 0x6f, 0x6c,
//         0x00, 0xce, 0xff, 0xff, 0xff, 0x00, 0x00, 0x02, 0x00, 0xc8, 0xff, 0xff, 0xff, 0x00, 0x00,
//         0x01, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x33, 0x32, 0x5f,
//         0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00, 0x06, 0x00, 0x06, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x14, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00,
//         0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x10,
//         0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x09, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00,
//         0x00, 0x08, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xa8,
//         0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x14, 0x00,
//         0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04,
//         0x00, 0x14, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
//         0x0a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00,
//         0x4c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09,
//         0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x61, 0x6c, 0x70, 0x68, 0x61, 0x62, 0x65, 0x74, 0x61, 0x67, 0x61, 0x6d, 0x6d, 0x61, 0x64,
//         0x65, 0x6c, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x48, 0x01,
//         0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x16, 0x00, 0x06,
//         0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00,
//         0x18, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
//         0x00, 0x18, 0x00, 0x0c, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0xbc, 0x00,
//         0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0xe4, 0x0b, 0x54, 0x02, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xf4, 0xab, 0xfd, 0xff, 0xff,
//         0xff, 0x14, 0x1a, 0x99, 0xbe, 0x1c, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//         0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x03, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x88, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xf5, 0x48, 0x40,
//         0x00, 0x00, 0xc0, 0x7f, 0xa4, 0x70, 0x2d, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28,
//         0x42, 0x00, 0xd0, 0x79, 0xc4, 0x00, 0x00, 0xa0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7d, 0xc3,
//         0x94, 0x25, 0xad, 0x49, 0xb2, 0x54, 0x30, 0x05, 0x8e, 0xe4, 0x2e, 0xff, 0x2b, 0xab, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
//         0x44, 0x8b, 0x6c, 0xe7, 0xfb, 0xa9, 0x0a, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
//         0x3f, 0x14, 0xae, 0x47, 0xe1, 0x7a, 0x14, 0x1f, 0x40, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
//         0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
//         0x00, 0x0c, 0x00, 0x14, 0x00, 0x06, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x10, 0x00, 0x0c, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x48, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x70, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x50, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0xa4, 0xff, 0xff, 0xff, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
//         0x18, 0x01, 0x00, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
//         0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x18, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00,
//         0x0c, 0x00, 0x10, 0x00, 0x14, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x14,
//         0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x64, 0x69, 0x63, 0x74, 0x5f, 0x63, 0x6f,
//         0x6c, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00,
//         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x20,
//         0x00, 0x00, 0x00, 0xd4, 0xff, 0xff, 0xff, 0x68, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x06,
//         0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x08, 0x00, 0x00, 0x00, 0x62, 0x6f, 0x6f, 0x6c, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00,
//         0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x98, 0xff, 0xff, 0xff, 0x00,
//         0x00, 0x01, 0x03, 0x10, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x36, 0x34,
//         0x5f, 0x63, 0x6f, 0x6c, 0x00, 0xce, 0xff, 0xff, 0xff, 0x00, 0x00, 0x02, 0x00, 0xc8, 0xff,
//         0xff, 0xff, 0x00, 0x00, 0x01, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x66, 0x6c, 0x6f, 0x61,
//         0x74, 0x33, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00, 0x06,
//         0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x14, 0x00, 0x08, 0x00,
//         0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x63,
//         0x6f, 0x6c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x07, 0x00, 0x08, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x41,
//         0x52, 0x52, 0x4f, 0x57, 0x31
//     ];

//     #[test]
//     fn test_decode_complex_stream_from_reference_arrow() {
//         let reference_stream_bytes: &[u8] = ARROW_COMPLEX_STREAM;
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::Stream);
//         let mut offset = 0;
//         let mut num_frames = 0;
//         while offset < reference_stream_bytes.len() {
//             match decoder.decode(&reference_stream_bytes[offset..]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => {
//                     assert!(frame.message.len() > 0);
//                     offset += consumed;
//                     num_frames += 1;
//                 }
//                 DecodeResult::NeedMore => break
//             }
//         }
//         assert!(num_frames >= 2);
//     }

//     #[test]
//     fn test_decode_complex_file_from_reference_arrow() {
//         let reference_file_bytes: &[u8] = ARROW_COMPLEX_FILE;
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::File);
//         let mut offset = 0;
//         let mut num_frames = 0;
//         while offset < reference_file_bytes.len() {
//             match decoder.decode(&reference_file_bytes[offset..]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => {
//                     assert!(frame.message.len() > 0);
//                     offset += consumed;
//                     num_frames += 1;
//                 }
//                 DecodeResult::NeedMore => break
//             }
//         }
//         assert!(num_frames >= 2);
//     }

//     // Datetime
//     //
//     // ```python
//     // import pyarrow as pa
//     // import pyarrow.ipc
//     // import numpy as np
//     // import datetime
//     //
//     // # All arrays length 7
//     // datetime_data = [
//     //     datetime.datetime(2024, 7, 1, 8, 0, 0, tzinfo=datetime.timezone.utc),
//     //     datetime.datetime(2024, 7, 2, 10, 30, 0, tzinfo=datetime.timezone.utc),
//     //     datetime.datetime(2024, 7, 3, 17, 45, 0, tzinfo=datetime.timezone.utc),
//     //     datetime.datetime(2024, 7, 4, 12, 15, 0, tzinfo=datetime.timezone.utc),
//     //     datetime.datetime(2025, 1, 1, 0, 0, 0, tzinfo=datetime.timezone.utc),
//     //     datetime.datetime(2038, 1, 19, 3, 14, 7, tzinfo=datetime.timezone.utc),
//     //     datetime.datetime(1999, 12, 31, 23, 59, 59, tzinfo=datetime.timezone.utc),
//     // ]
//     // datetime_array = pa.array(datetime_data, type=pa.timestamp('ms', tz='UTC'))
//     //
//     // schema = pa.schema([
//     //     ('datetime_col', pa.timestamp('ms', tz='UTC'))
//     // ])
//     //
//     // batch = pa.record_batch([
//     //     datetime_array
//     // ], schema=schema)
//     //
//     // # Write stream format (.arrows)
//     // with open("arrow_complex_stream.arrows", "wb") as f:
//     //     with pa.ipc.new_stream(f, schema) as writer:
//     //         writer.write_batch(batch)
//     //
//     // # Write file format (.arrow)
//     // with open("arrow_complex_file.arrow", "wb") as f:
//     //     with pa.ipc.new_file(f, schema) as writer:
//     //         writer.write_batch(batch)
//     //
//     // # Print Rust consts for embedding
//     // with open("arrow_complex_stream.arrows", "rb") as f:
//     //     stream_bytes = f.read()
//     // print("COMPLEX STREAM FORMAT (for Rust):\nconst ARROW_COMPLEX_STREAM: &[u8] = &[\n    {} \n];"
//     //     .format(', '.join(f'0x{b:02x}' for b in stream_bytes)))
//     //
//     // with open("arrow_complex_file.arrow", "rb") as f:
//     //     file_bytes = f.read()
//     // print("COMPLEX FILE FORMAT (for Rust):\nconst ARROW_COMPLEX_FILE: &[u8] = &[\n    {} \n];"
//     //     .format(', '.join(f'0x{b:02x}' for b in file_bytes)))
//     // ```

//     const ARROW_DATETIME_STREAM: &[u8] = &[
//         0xff, 0xff, 0xff, 0xff, 0x90, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
//         0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08,
//         0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
//         0x10, 0x00, 0x14, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10,
//         0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0a, 0x10, 0x00, 0x00, 0x00, 0x28, 0x00,
//         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x64,
//         0x61, 0x74, 0x65, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00,
//         0x08, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x55, 0x54, 0x43, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x88, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x0c, 0x00, 0x16, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00,
//         0x0c, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x04, 0x00,
//         0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x07,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x4e, 0x6d,
//         0x90, 0x01, 0x00, 0x00, 0x40, 0x80, 0xfe, 0x72, 0x90, 0x01, 0x00, 0x00, 0x60, 0x1d, 0xb3,
//         0x79, 0x90, 0x01, 0x00, 0x00, 0xa0, 0x59, 0xab, 0x7d, 0x90, 0x01, 0x00, 0x00, 0x00, 0x7c,
//         0x29, 0x1f, 0x94, 0x01, 0x00, 0x00, 0x18, 0xfc, 0xff, 0xff, 0xf3, 0x01, 0x00, 0x00, 0x18,
//         0xa8, 0xcf, 0x6a, 0xdc, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
//     ];

//     const ARROW_DATETIME_FILE: &[u8] = &[
//         0x41, 0x52, 0x52, 0x4f, 0x57, 0x31, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x90, 0x00, 0x00,
//         0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00,
//         0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x08,
//         0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
//         0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00, 0x08, 0x00, 0x06,
//         0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x01, 0x0a, 0x10, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x65, 0x74, 0x69, 0x6d, 0x65,
//         0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x08,
//         0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00,
//         0x00, 0x00, 0x55, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x88,
//         0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x16, 0x00,
//         0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04,
//         0x00, 0x18, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x0a, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x3c,
//         0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
//         0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x4e, 0x6d, 0x90, 0x01, 0x00, 0x00, 0x40, 0x80, 0xfe,
//         0x72, 0x90, 0x01, 0x00, 0x00, 0x60, 0x1d, 0xb3, 0x79, 0x90, 0x01, 0x00, 0x00, 0xa0, 0x59,
//         0xab, 0x7d, 0x90, 0x01, 0x00, 0x00, 0x00, 0x7c, 0x29, 0x1f, 0x94, 0x01, 0x00, 0x00, 0x18,
//         0xfc, 0xff, 0xff, 0xf3, 0x01, 0x00, 0x00, 0x18, 0xa8, 0xcf, 0x6a, 0xdc, 0x00, 0x00, 0x00,
//         0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x14,
//         0x00, 0x06, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x04, 0x00, 0x38, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01,
//         0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00,
//         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10,
//         0x00, 0x14, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00,
//         0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0a, 0x10, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00,
//         0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x64, 0x61,
//         0x74, 0x65, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x63, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x08,
//         0x00, 0x0c, 0x00, 0x06, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
//         0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x55, 0x54, 0x43, 0x00, 0xb8, 0x00, 0x00,
//         0x00, 0x41, 0x52, 0x52, 0x4f, 0x57, 0x31
//     ];

//     #[test]
//     fn test_decode_datetime_stream_from_reference_arrow() {
//         let reference_stream_bytes: &[u8] = ARROW_DATETIME_STREAM;
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::Stream);
//         let mut offset = 0;
//         let mut num_frames = 0;
//         while offset < reference_stream_bytes.len() {
//             match decoder.decode(&reference_stream_bytes[offset..]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => {
//                     assert!(frame.message.len() > 0);
//                     offset += consumed;
//                     num_frames += 1;
//                 }
//                 DecodeResult::NeedMore => break
//             }
//         }
//         assert!(num_frames >= 2);
//     }

//     #[test]
//     fn test_decode_datetime_file_from_reference_arrow() {
//         let reference_file_bytes: &[u8] = ARROW_DATETIME_FILE;
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::File);
//         let mut offset = 0;
//         let mut num_frames = 0;
//         while offset < reference_file_bytes.len() {
//             match decoder.decode(&reference_file_bytes[offset..]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => {
//                     assert!(frame.message.len() > 0);
//                     offset += consumed;
//                     num_frames += 1;
//                 }
//                 DecodeResult::NeedMore => break
//             }
//         }
//         assert!(num_frames >= 2);
//     }

//     fn build_minimal_schema_message() -> Vec<u8> {
//         let mut fbb = FlatBufferBuilder::new();

//         // Example: one int32 field called "f0"
//         let name = fbb.create_string("f0");
//         let int_type = fb::Int::create(&mut fbb, &fb::IntArgs { bitWidth: 32, is_signed: true });

//         let field = fb::Field::create(
//             &mut fbb,
//             &fb::FieldArgs {
//                 name: Some(name),
//                 nullable: true,
//                 type_type: fb::Type::Int,
//                 type_: Some(int_type.as_union_value()),
//                 dictionary: None,
//                 children: None,
//                 custom_metadata: None
//             }
//         );

//         let fields = fbb.create_vector(&[field]);

//         let schema = fb::Schema::create(
//             &mut fbb,
//             &fb::SchemaArgs {
//                 endianness: fb::Endianness::Little,
//                 fields: Some(fields),
//                 custom_metadata: None,
//                 features: None
//             }
//         );

//         let msg = fb::Message::create(
//             &mut fbb,
//             &fb::MessageArgs {
//                 version: fb::MetadataVersion::V5,
//                 header_type: fb::MessageHeader::Schema,
//                 header: Some(schema.as_union_value()),
//                 bodyLength: 0,
//                 custom_metadata: None
//             }
//         );

//         fbb.finish(msg, None);
//         fbb.finished_data().to_vec()
//     }

//     fn build_record_batch_message(n_values: usize) -> (Vec<u8>, Vec<u8>) {
//         let mut fbb = FlatBufferBuilder::new();

//         // Create a single column (Int32 array) for n_values.
//         let data: Vec<i32> = (0..n_values as i32).collect();
//         let data_bytes: &[u8] =
//             unsafe { std::slice::from_raw_parts(data.as_ptr() as *const u8, n_values * 4) };
//         // No nulls, so null_count = 0, length = n_values
//         let field_node = fb::FieldNode::new(n_values as i64, 0);
//         let field_nodes = fbb.create_vector(&[field_node]);
//         let buffers = [
//             fb::Buffer::new(0, 0),                     // Null buffer (not used)
//             fb::Buffer::new(0, (n_values * 4) as i64)  // Data buffer (follows)
//         ];
//         let buffers_vec = fbb.create_vector(&buffers);

//         let rec_batch = fb::RecordBatch::create(
//             &mut fbb,
//             &fb::RecordBatchArgs {
//                 length: n_values as i64,
//                 nodes: Some(field_nodes),
//                 buffers: Some(buffers_vec),
//                 compression: None,
//                 variadicBufferCounts: None
//             }
//         );

//         let msg = fb::Message::create(
//             &mut fbb,
//             &fb::MessageArgs {
//                 version: fb::MetadataVersion::V5,
//                 header_type: fb::MessageHeader::RecordBatch,
//                 header: Some(rec_batch.as_union_value()),
//                 bodyLength: (n_values * 4) as i64,
//                 custom_metadata: None
//             }
//         );

//         fbb.finish(msg, None);
//         (fbb.finished_data().to_vec(), data_bytes.to_vec())
//     }

//     #[test]
//     fn test_decode_stream_schema_and_batch() {
//         // Build a real Arrow schema message and record batch
//         let schema_msg = build_minimal_schema_message();
//         let (batch_msg, batch_body) = build_record_batch_message(4);

//         // Encode both as Arrow IPC frames using canonical framer (with continuation)
//         let schema_frame = ArrowIPCEncoder::encode_frame(
//             &schema_msg,
//             &[],
//             IPCMessageProtocol::Stream,
//             false,
//             false,
//             None
//         );
//         let batch_frame = ArrowIPCEncoder::encode_frame(
//             &batch_msg,
//             &batch_body,
//             IPCMessageProtocol::Stream,
//             false,
//             false,
//             None
//         );

//         // Concatenate frames as a byte stream
//         let mut stream_bytes = Vec::new();
//         stream_bytes.extend_from_slice(&schema_frame);
//         stream_bytes.extend_from_slice(&batch_frame);

//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::Stream);

//         // Decode schema frame
//         let result = decoder.decode(&stream_bytes[..schema_frame.len()]).unwrap();
//         match result {
//             DecodeResult::Frame { frame, consumed } => {
//                 assert_eq!(frame.message.as_slice(), &schema_msg[..]);
//                 assert!(frame.body.is_empty());
//                 assert_eq!(consumed, schema_frame.len());
//             }
//             _ => panic!("Expected schema frame")
//         }

//         // Decode batch frame (offset by schema frame length)
//         let result = decoder.decode(&stream_bytes[schema_frame.len()..]).unwrap();
//         match result {
//             DecodeResult::Frame { frame, consumed } => {
//                 assert_eq!(frame.message.as_slice(), &batch_msg[..]);
//                 assert_eq!(frame.body.as_slice(), &batch_body[..]);
//                 assert_eq!(consumed, batch_frame.len());
//             }
//             _ => panic!("Expected record batch frame")
//         }
//     }

//     #[test]
//     fn test_decode_file_schema_batch_footer() {
//         // Build schema, batch, and footer messages
//         let schema_msg = build_minimal_schema_message();
//         let (batch_msg, batch_body) = build_record_batch_message(2);

//         let footer: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8];

//         let schema_frame = ArrowIPCEncoder::encode_frame(
//             &schema_msg,
//             &[],
//             IPCMessageProtocol::File,
//             true,
//             false,
//             None
//         );
//         let batch_frame = ArrowIPCEncoder::encode_frame(
//             &batch_msg,
//             &batch_body,
//             IPCMessageProtocol::File,
//             false,
//             false,
//             None
//         );
//         let last_frame = ArrowIPCEncoder::encode_frame(
//             &batch_msg,
//             &batch_body,
//             IPCMessageProtocol::File,
//             false,
//             true,
//             Some(&footer)
//         );

//         let mut file_bytes = Vec::new();
//         file_bytes.extend_from_slice(&schema_frame);
//         file_bytes.extend_from_slice(&batch_frame);
//         file_bytes.extend_from_slice(&last_frame);

//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::File);

//         // Schema
//         let (frame, consumed) = match decoder.decode(&file_bytes[..schema_frame.len()]).unwrap() {
//             DecodeResult::Frame { frame, consumed } => (frame, consumed),
//             _ => panic!("Expected schema frame")
//         };
//         assert_eq!(frame.message.as_slice(), &schema_msg[..]);
//         assert!(frame.body.is_empty());
//         assert_eq!(consumed, schema_frame.len());

//         // Batch
//         let offset = schema_frame.len();
//         let (frame, consumed) =
//             match decoder.decode(&file_bytes[offset..offset + batch_frame.len()]).unwrap() {
//                 DecodeResult::Frame { frame, consumed } => (frame, consumed),
//                 _ => panic!("Expected batch frame")
//             };
//         assert_eq!(frame.message.as_slice(), &batch_msg[..]);
//         assert_eq!(frame.body.as_slice(), &batch_body[..]);
//         assert_eq!(consumed, batch_frame.len());

//         // Last frame (batch + footer + magic)
//         let offset2 = offset + batch_frame.len();
//         let rest = &file_bytes[offset2..];

//         match decoder.decode(rest).unwrap() {
//             DecodeResult::Frame { frame, consumed } => {
//                 assert_eq!(frame.message.as_slice(), &batch_msg[..]);
//                 assert_eq!(frame.body.as_slice(), &batch_body[..]);

//                 // Footer+magic is processed next
//                 let rest2 = &rest[consumed..];
//                 let footer_result = decoder.decode(rest2).unwrap();
//                 match footer_result {
//                     DecodeResult::NeedMore => (), // Done
//                     _ => panic!("Expected need more (footer end)")
//                 }

//                 let expected_len = last_frame.len();
//                 assert_eq!(consumed + rest2.len(), expected_len);
//             }
//             _ => panic!("Expected last batch+footer frame")
//         }
//     }

//     #[test]
//     fn test_decode_with_partial_chunks() {
//         // Build schema message and record batch
//         let schema_msg = build_minimal_schema_message();
//         let (batch_msg, batch_body) = build_record_batch_message(1);

//         let schema_frame = ArrowIPCEncoder::encode_frame(
//             &schema_msg,
//             &[],
//             IPCMessageProtocol::Stream,
//             false,
//             false,
//             None
//         );
//         let batch_frame = ArrowIPCEncoder::encode_frame(
//             &batch_msg,
//             &batch_body,
//             IPCMessageProtocol::Stream,
//             false,
//             false,
//             None
//         );

//         // Interleave and fragment the stream into small chunks
//         let mut stream_bytes = Vec::new();
//         stream_bytes.extend_from_slice(&schema_frame);
//         stream_bytes.extend_from_slice(&batch_frame);

//         // Feed chunks incrementally to test decoder "NeedMore"
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::Stream);

//         // Schema frame by small increments
//         for chunk in 1..schema_frame.len() {
//             let partial = &stream_bytes[..chunk];
//             let result = decoder.decode(partial);
//             if chunk < schema_frame.len() {
//                 assert!(matches!(result, Ok(DecodeResult::NeedMore)));
//             }
//         }
//         // Full decode after complete schema frame
//         let result = decoder.decode(&stream_bytes[..schema_frame.len()]).unwrap();
//         assert!(matches!(result, DecodeResult::Frame { .. }));

//         // Batch frame in increments
//         let offset = schema_frame.len();
//         for chunk in 1..batch_frame.len() {
//             let partial = &stream_bytes[offset..offset + chunk];
//             let result = decoder.decode(partial);
//             if chunk < batch_frame.len() {
//                 assert!(matches!(result, Ok(DecodeResult::NeedMore)));
//             }
//         }
//         let result = decoder.decode(&stream_bytes[offset..offset + batch_frame.len()]).unwrap();
//         assert!(matches!(result, DecodeResult::Frame { .. }));
//     }

//     #[test]
//     fn test_decode_file_schema_batch_footer_in_fragments() {
//         // Build schema, batch, and footer messages
//         let schema_msg = build_minimal_schema_message();
//         let (batch_msg, batch_body) = build_record_batch_message(2);

//         let footer: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8];

//         let schema_frame = ArrowIPCEncoder::encode_frame(
//             &schema_msg,
//             &[],
//             IPCMessageProtocol::File,
//             true,
//             false,
//             None
//         );
//         let batch_frame = ArrowIPCEncoder::encode_frame(
//             &batch_msg,
//             &batch_body,
//             IPCMessageProtocol::File,
//             false,
//             false,
//             None
//         );
//         let last_frame = ArrowIPCEncoder::encode_frame(
//             &batch_msg,
//             &batch_body,
//             IPCMessageProtocol::File,
//             false,
//             true,
//             Some(&footer)
//         );

//         // Get the full bytes of the file including footer and magic
//         let mut file_bytes = Vec::new();
//         file_bytes.extend_from_slice(&schema_frame);
//         file_bytes.extend_from_slice(&batch_frame);
//         file_bytes.extend_from_slice(&last_frame);

//         // Offset of last_frame within the total buffer
//         let offset2 = schema_frame.len() + batch_frame.len();
//         let last_bytes = &file_bytes[offset2..];

//         // Fragment the last frame, footer, and magic into small pieces
//         let mut decoder = ArrowIPCFrameDecoder::new(IPCMessageProtocol::File);

//         // Decode schema
//         let result = decoder.decode(&file_bytes[..schema_frame.len()]).unwrap();
//         match result {
//             DecodeResult::Frame { frame, consumed: _ } => {
//                 assert_eq!(frame.message.as_slice(), &schema_msg[..]);
//                 assert!(frame.body.is_empty());
//             }
//             _ => panic!("Expected schema frame")
//         }

//         // Decode batch
//         let offset = schema_frame.len();
//         let result = decoder.decode(&file_bytes[offset..offset + batch_frame.len()]).unwrap();
//         match result {
//             DecodeResult::Frame { frame, consumed: _ } => {
//                 assert_eq!(frame.message.as_slice(), &batch_msg[..]);
//                 assert_eq!(frame.body.as_slice(), &batch_body[..]);
//             }
//             _ => panic!("Expected batch frame")
//         }

//         // Decode last frame and then footer/magic in fragments
//         // Find the length of the record batch part in last_frame (excluding footer/magic)
//         let record_batch_len = last_frame.len() - (footer.len() + 4 + 8);
//         let record_batch_bytes = &last_bytes[..record_batch_len];

//         // 1. Feed just the record batch part
//         let result = decoder.decode(record_batch_bytes).unwrap();
//         match result {
//             DecodeResult::Frame { frame, consumed: _ } => {
//                 assert_eq!(frame.message.as_slice(), &batch_msg[..]);
//                 assert_eq!(frame.body.as_slice(), &batch_body[..]);
//             }
//             _ => panic!("Expected last record batch frame")
//         }

//         // 2. Feed the footer and magic one byte at a time, expect NeedMore until all is present
//         let tail_bytes = &last_bytes[record_batch_len..];
//         let mut acc = Vec::new();
//         for (i, b) in tail_bytes.iter().enumerate() {
//             acc.push(*b);
//             let result = decoder.decode(&acc);
//             if i < tail_bytes.len() - 1 {
//                 assert!(
//                     matches!(result, Ok(DecodeResult::NeedMore)),
//                     "Expected NeedMore for tail fragment of length {}",
//                     acc.len()
//                 );
//             } else {
//                 // After final byte, should be fully consumed and in Done state (no frame to emit)
//                 assert!(
//                     matches!(result, Ok(DecodeResult::NeedMore)),
//                     "Expected NeedMore after full footer+magic"
//                 );
//                 assert!(matches!(decoder.state, DecodeState::Done));
//             }
//         }
//     }
// }
